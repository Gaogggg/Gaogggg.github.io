<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gaoge&#39;s island</title>
    <link>https://Gaogggg.github.io/index.xml</link>
    <description>Recent content on Gaoge&#39;s island</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2016</copyright>
    <lastBuildDate>Tue, 20 Dec 2016 13:18:24 +0800</lastBuildDate>
    <atom:link href="https://Gaogggg.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Effective Java ReadingNotes 5</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes5/</link>
      <pubDate>Tue, 20 Dec 2016 13:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes5/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(5)&lt;/p&gt;

&lt;p&gt;Effective Java第6章 枚举和注解&lt;/p&gt;

&lt;h5&gt;30.用enum代替int常量&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public enum PayrollDay {  
    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(  
            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(  
            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);  
    private final PayType payType;  
  
    PayrollDay(PayType payType) {  
        this.payType = payType;  
    }  
      
    double pay(double hoursWorked, double payRate) {  
        return payType.pay(hoursWorked, payRate);  
    }  
  
    private enum PayType {  
        WEEKDAY {  
            double overtimePay(double hours, double payRate) {  
                return hours &lt;= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT)  
                        * payRate / 2;  
            }  
        },  
        WEEKEND {  
            double overtimePay(double hours, double payRate) {  
                return hours * payRate / 2;  
            }  
        };  
        private static final int HOURS_PER_SHIFT = 8;  
  
        abstract double overtimePay(double hours, double payRate);  
  
        double pay(double hoursWorked, double payRate) {  
            double basePay = hoursWorked * payRate;  
            return basePay + overtimePay(hoursWorked, payRate);  
        }  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;int&lt;/code&gt;常量相比，枚举要易读得多，也更加安全，功能更加强大。许多枚举都不需要显式的构造器或者成员，但许多其它枚举则受益于“每个常量与属性的关联”以及“提供行为受这个属性影响的方法”。只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个枚举常量同时享有相同的行为，则考虑策略枚举。&lt;/p&gt;

&lt;h5&gt;31.用实例域代替序数&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实力域中。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Ensemble{
  SOLO(1), DUET(2), TRIO(3), QUINTET(4), SEXTET(5), 
  SEPTET(7), OCTET(8), DOUBLE_QUARTET(8), NONET(9),
  DECTET(10), TRIPLE_QUARTRT(12);
  
  private final int numberOfMusicians;
  Ensemble(int size){
    this.numberOfMusicians = size;
  }
  public int numberofMusicians(){
    return numberOfMusicians;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enum&lt;/code&gt;规范中谈到&lt;code&gt;ordinal&lt;/code&gt;时这么写到：“大多数的程序员都不需要这个方法。它是设计成用于像&lt;code&gt;EnumSet&lt;/code&gt;和&lt;code&gt;EnumMap&lt;/code&gt;这种基于枚举的通用数据结构的。”除非你在编写的是这种数据结构，否则最好完全避免使用&lt;code&gt;ordinal&lt;/code&gt;方法。&lt;/p&gt;

&lt;h5&gt;32.用EnumSet代替位域&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;EnumSet&lt;/code&gt;类集位域的简洁和性能优势及第&lt;code&gt;30&lt;/code&gt;条中所述的枚举类型的所有的优点于一身。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Text{
    public enum TextStyle{BOLD, ITALIC, UNDERLINE, STRIKETHROUGH}
    public void applyStyles(Set&amp;lt;TextStyle&gt; styles){...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是将&lt;code&gt;EnumSet&lt;/code&gt;实例传递给&lt;code&gt;applyStyles&lt;/code&gt;方法的客户端代码。&lt;code&gt;EnumSet&lt;/code&gt;提供了丰富的静态工厂来创建集合，其中一个如这个代码所示：&lt;code&gt;text.applyStyles(EnumSet.of(TextStyle.BOLD,TextStyle.ITALIC));&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;33.用EnumMap代替序数索引&lt;/h5&gt;

&lt;p&gt;序数索引是指依赖于枚举成员在枚举中的序数来进行数组索引，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Plant{
    public enum Type { Fruit, Vegetables, Tree}
    private final String name;
    private final Type type;

    Plant(String name, Type type){
        this.name = name;
        this.type = type;
    }
}

Set&amp;lt;Plant&gt;[] plants = (Set&lt;Plant&gt;[]) new Set[Plant.Type.valuse().lenght]; 
//根据植物的类型，分别把所有的植物放入三个set中
for(int i = 0; i &lt; plant.lenght; i++){
   plant[i] = new HashSet&lt;Plant&gt;();
}

for(Plant p : garden){  //garden里放了所有的植物
    plant[p.type.ordinal()].add(p)  //反面教材：利用了枚举的序数来得到想要的数组索引，用户在其他地方可以不使用ordinal函数，而直接使用int值来访问，就可能出错
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该使用&lt;code&gt;EnumMap&lt;/code&gt;来实现，&lt;code&gt;EnumMap&lt;/code&gt;内部是采用数组实现的，具有&lt;code&gt;Map&lt;/code&gt;的丰富功能和类型安全以及数组的效率：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;Plant.Type, Set&lt;Plant&gt;&gt; plants = new EnumMap&amp;lt;Plant.Type, Set&lt;Plant&gt;&gt;(Plant.Type.class);  //构造函数需要 键 类型的Class对象
//根据植物的类型，分别把所有的植物放入三个set中
for(Plant.Type type : Plant.Type.valuse()){
   plant.put(type, new HashSet&lt;Plant&gt;);
}

for(Plant p : garden){  //garden里放了所有的植物
    plant.get(p.type).add(p)  //用户必须使用正确的键值来访问，即Type类型
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要多维关系时，可以使用&lt;code&gt;EnumMap&amp;lt;..., EnumMap&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;34.用接口模拟可伸缩的枚举&lt;/h5&gt;

&lt;p&gt;虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。这样允许客户端编写自己的枚举来实现接口。如果API是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Operation{
    double apply(double x,double y);
}

public enum BasicOperation implements Operation{

    PLUS(&#34;^&#34;){
        public double apply(double x,double y){ return Math.pow(x,y);}
    },
    MINUS(&#34;%&#34;){
        public double apply(double x,double y){ return x % y;}
    };

    private final String symbool;
    BasicOperation(String symbool){ this.symbool = symbool}

    @Override
    public String toString() {
        return symbool;
    }

    @Override
    public double apply(double x, double y) {
        return 0;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过以下两种方法传递完整的扩展枚举类型，并使用它的元素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;T extends Enum&amp;lt;T&amp;gt; &amp;amp; Operation&amp;gt; Class&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Collection&amp;lt;? Extends Operation&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;35.注解优先于命名模式&lt;/h5&gt;

&lt;p&gt;命名模式的缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;无法处理命名失误的情况；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无法确保它们只用于响应的程序元素上；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;他们没有提供将参数值与程序元素关联起来的好方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;36.坚持使用Override注解&lt;/h5&gt;

&lt;p&gt;在每个方法声明中使用&lt;code&gt;Override&lt;/code&gt;注解来覆盖超类声明。&lt;/p&gt;

&lt;h5&gt;37.用标记接口定义类型&lt;/h5&gt;

&lt;p&gt;标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型；标记接口可以被更加精确地进行锁定。&lt;/p&gt;

&lt;p&gt;标记注解胜过标记接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给已被使用的注解类型添加更多的信息，它的另一个优点在于它们使更大的注解机制的一部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果想要定义类型，一定要使用接口。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 1 - 10</title>
      <link>https://gaogggg.github.io/post/leetcode/leetcode-1-10/</link>
      <pubDate>Mon, 19 Dec 2016 16:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/leetcode/leetcode-1-10/</guid>
      <description>&lt;h5&gt;1. Two Sum&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int[] twoSum(int[] nums, int target) {
        int result[] = new int[2];
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0; i &lt; nums.length; i++){
            if(map.containsKey(target - nums[i])){
                result[1] = i;
                result[0] = map.get(target - nums[i]);
                return result;
            }
            map.put(nums[i], i);
        }
        return result;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2. Add Two Numbers&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode result = new ListNode(0);
        ListNode temp = result;
        int sum = 0;
        while(l1 != null || l2 != null){
            sum/=10;
            if(l1 != null){
                sum += l1.val;
                l1 = l1.next;
            }
            if(l2 != null){
                sum += l2.val;
                l2 = l2.next;
            }
            temp.next = new ListNode(sum%10);
            temp = temp.next;
        }
        if(sum/10 &gt;= 1){
            temp.next = new ListNode(sum/10);
        }
        return result.next;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;3. Longest Substring Without Repeating Characters&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(0 == s.length()) return 0;
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int max = 0;
        for(int i = 0, j = 0; i&lt;s.length(); i++){
            if(map.containsKey(s.charAt(i))){
                j = Math.max(j, map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i - j + 1);
        }
        return max;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;4. Median of Two Sorted Arrays&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        int m = A.length, n = B.length;
        int l = (m + n + 1) / 2;
        int r = (m + n + 2) / 2;
        return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;
    }

    public double getkth(int[] A, int aStart, int[] B, int bStart, int k) {
        if (aStart &gt; A.length - 1) return B[bStart + k - 1];            
        if (bStart &gt; B.length - 1) return A[aStart + k - 1];                
        if (k == 1) return Math.min(A[aStart], B[bStart]);
    
        int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;
        if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; 
        if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1];        
    
        if (aMid &lt; bMid) 
            return getkth(A, aStart + k/2, B, bStart,       k - k/2); 
        else 
            return getkth(A, aStart,       B, bStart + k/2, k - k/2);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;5. Longest Palindromic Substring&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    private int lo, maxLen;
    
    public String longestPalindrome(String s) {
        if (s.length() &lt; 2){
            return s;
        }
    
        for (int i = 0; i &lt; s.length()-1; i++) {
            extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible
            extendPalindrome(s, i, i+1); //assume even length.
        }
        return s.substring(lo, lo + maxLen);
    }
    
    private void extendPalindrome(String s, int j, int k) {
        while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) {
            j--;
            k++;
        }
        if (maxLen &lt; k - j - 1) {
            lo = j + 1;
            maxLen = k - j - 1;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pokemon Button</title>
      <link>https://gaogggg.github.io/post/android/pokemon-button/</link>
      <pubDate>Mon, 19 Dec 2016 00:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/android/pokemon-button/</guid>
      <description>&lt;p&gt;&lt;code&gt;PokemonButton&lt;/code&gt;是受&lt;a href=&#34;https://github.com/jd-alexander/LikeButton&#34;&gt;LikeButton&lt;/a&gt;和&lt;a href=&#34;https://github.com/frogermcs/LikeAnimation&#34;&gt;LikeAnimation&lt;/a&gt;的启发，类似&lt;code&gt;Twitter&lt;/code&gt;的&lt;code&gt;Like&lt;/code&gt;动画的一种实现。&lt;/p&gt;

&lt;p&gt;具体效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://Gaogggg.github.io/post/android/pokemonbutton.gif&#34; alt=&#34;pokemonbutton&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该动画效果是通过手动绘制和使用&lt;code&gt;ObjectAnimator&lt;/code&gt;实现的，相较帧动画，这样的解决方案更为灵活。这篇文章只是一个简单的概述，如果想要知道更多的细节，可以在我的&lt;code&gt;GitHub&lt;/code&gt;中查看源代码——&lt;a href=&#34;https://github.com/Gaogggg/PokemonButton&#34;&gt;PokemonButton&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PokemonButton&lt;/code&gt;是一个继承&lt;code&gt;FrameLayout&lt;/code&gt;的&lt;code&gt;View&lt;/code&gt;，该&lt;code&gt;View&lt;/code&gt;托管三个&lt;code&gt;ChildView&lt;/code&gt; - &lt;code&gt;PokeBallView&lt;/code&gt;显示精灵球图形，&lt;code&gt;ImageView&lt;/code&gt;显示精灵的&lt;code&gt;Image&lt;/code&gt;，&lt;code&gt;TypeView&lt;/code&gt;呈现与精灵属性相应的点缀效果图。&lt;/p&gt;

&lt;h5&gt;PokeBallView&lt;/h5&gt;

&lt;p&gt;这个&lt;code&gt;View&lt;/code&gt;负责绘制精灵图标下面的精灵球图案。使用&lt;code&gt;Paint&lt;/code&gt;和&lt;code&gt;Path&lt;/code&gt;在&lt;code&gt;Canvas&lt;/code&gt;上绘制：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    tempCanvas.drawColor(0xffffff, PorterDuff.Mode.CLEAR);

    drawPokeBall(getWidth() / 2, getHeight() / 2, outerCircleRadiusProgress * maxCircleSize,tempCanvas);
    tempCanvas.drawCircle(getWidth() / 2, getHeight() / 2, innerCircleRadiusProgress * maxCircleSize +  paintBlack.getStrokeWidth(), maskPaint);
    canvas.drawBitmap(tempBitmap, 0, 0, null);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个&lt;code&gt;View&lt;/code&gt;分为两层，外圈的精灵球图案以及内圈的擦除圆。&lt;/p&gt;

&lt;p&gt;精灵球图案分为上半球、下半球以及轮廓的绘制：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void drawPokeBall(float cx, float cy, float radius, Canvas canvas){
    RectF outerBall = new RectF(cx-radius, cy-radius, cx+radius, cy+radius);

    RectF innerBall = new RectF(cx-radius/3,cy-radius/3,cx + radius/3,cy + radius/3);

    pathTopBall.reset();
    pathBlack.reset();
    pathBottomBall.reset();

    pathTopBall.moveTo(cx - radius,cy);
    pathTopBall.lineTo(cx - radius/3,cy);
    pathTopBall.arcTo(new RectF(innerBall),180,180);
    pathTopBall.lineTo(cx + radius,cy);
    pathTopBall.arcTo(new RectF(outerBall),0,-180);
    pathTopBall.close();

    pathBottomBall.moveTo(cx - radius, cy);
    pathBottomBall.lineTo(cx - radius/3, cy);
    pathBottomBall.arcTo(new RectF(innerBall),180,-180);
    pathBottomBall.lineTo(cx + radius,cy);
    pathBottomBall.arcTo(new RectF(outerBall),0,180);
    pathBottomBall.close();

    pathBlack.moveTo(cx - radius, cy);
    pathBlack.lineTo(cx - radius/3,cy);
    pathBlack.moveTo(cx + radius/3, cy);
    pathBlack.lineTo(cx + radius, cy);

    canvas.drawPath(pathTopBall,paintTopBall);
    canvas.drawPath(pathBottomBall,paintBottomBall);
    canvas.drawPath(pathBlack,paintBlack);

    canvas.drawCircle(cx,cy,radius/3,paintBlack);
    canvas.drawCircle(cx,cy,radius,paintBlack);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个帧从清除整个画布开始，通过使用&lt;code&gt;CLEAR&lt;/code&gt;模式的画笔。然后根据给定的进度绘制内圈和外圈：&lt;code&gt;maskPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就能产生一个透明孔由内向外扩大使精灵球图案消失的效果。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;View&lt;/code&gt;所用的&lt;code&gt;tempCanvas&lt;/code&gt;和&lt;code&gt;tempBitmap&lt;/code&gt;是在这里定义的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    paintBlack.setStrokeWidth(w/20);
    maxCircleSize = w / 2 - (int)paintBlack.getStrokeWidth();
    tempBitmap = Bitmap.createBitmap(getWidth(), getWidth(), Bitmap.Config.ARGB_8888);
    tempCanvas = new Canvas(tempBitmap);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，&lt;code&gt;PokeBallView&lt;/code&gt;能根据当前的进展改变其颜色。由&lt;code&gt;ArgbEvaluator&lt;/code&gt;完成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void updateCircleColor() {
    float colorProgress = (float) Utils.clamp(outerCircleRadiusProgress, 0.5, 1);
    colorProgress = (float) Utils.mapValueFromRangeToRange(colorProgress, 0.5f, 1f, 0f, 1f);
    this.paintTopBall.setColor((Integer) argbEvaluator.evaluate(colorProgress, 0, TOP_HALF_BALL_COLOR));
    this.paintBottomBall.setColor((Integer) argbEvaluator.evaluate(colorProgress, 0, BOTTOM_HALF_BALL_COLOR));
    this.paintBlack.setColor((Integer) argbEvaluator.evaluate(colorProgress, 0, BLACK_COLOR));
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;TypeView&lt;/h5&gt;

&lt;p&gt;这个类是呈现与精灵属性相应的点缀效果图的抽象类，和&lt;code&gt;PokeBallView&lt;/code&gt;类似，在&lt;code&gt;onDraw()&lt;/code&gt;中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onDraw(Canvas canvas) {
    drawOuterTypesFrame(canvas);
    drawInnerTypesFrame(canvas);
}

private void drawOuterTypesFrame(Canvas canvas) {
    for (int i = 0; i &lt; TYPES_COUNT; i++) {
        int cX = (int) (centerX + currentRadius1 * Math.cos(i * OUTER_TYPES_POSITION_ANGLE * Math.PI / 180));
        int cY = (int) (centerY + currentRadius1 * Math.sin(i * OUTER_TYPES_POSITION_ANGLE * Math.PI / 180));
        drawType(cX, cY, currentTypeSize1, canvas);
    }
}

private void drawInnerTypesFrame(Canvas canvas) {
    for (int i = 0; i &lt; TYPES_COUNT; i++) {
        int cX = (int) (centerX + currentRadius2 * Math.cos((i * OUTER_TYPES_POSITION_ANGLE - 10) * Math.PI / 180));
        int cY = (int) (centerY + currentRadius2 * Math.sin((i * OUTER_TYPES_POSITION_ANGLE - 10) * Math.PI / 180));
        drawType(cX, cY, currentTypeSize2, canvas);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点缀效果是基于当前进度进行绘制的，它们排列在不可见圆上——位置由以下因素决定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int cX = (int) (centerX + currentRadius1 * Math.cos(i * OUTER_TYPES_POSITION_ANGLE * Math.PI / 180));
int cY = (int) (centerY + currentRadius1 * Math.sin(i * OUTER_TYPES_POSITION_ANGLE * Math.PI / 180));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的点缀效果绘制交由继承该类的具体实现来进行。以目前已经实现的四个效果之一的&lt;code&gt;Electric&lt;/code&gt;为例。&lt;code&gt;Electric&lt;/code&gt;需要实现该抽象类的四个抽象方法，分别为&lt;code&gt;init()&lt;/code&gt;——进行绘制所需的初始化，&lt;code&gt;drawType(float cx, float cy, float radius, Canvas canvas)&lt;/code&gt;——实际绘制，&lt;code&gt;updateTypesPaints(float currentProgress)&lt;/code&gt;——根据当前进度调整画笔状态，&lt;code&gt;updateTypesAlpha(int alpha)&lt;/code&gt;——根据当前进度调整画笔透明度。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Electric&lt;/code&gt;的相关实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void init() {

    paintElectric = new Paint();
    paintElectric.setAntiAlias(true);
    paintElectric.setStyle((Paint.Style.FILL));
}

@Override
protected void drawType(float cx, float cy, float radius, Canvas canvas) {
    pathElectric.reset();

    pathElectric.moveTo(cx - radius/2,cy - radius/4);
    pathElectric.lineTo(cx + radius,cy - 3*radius/4);
    pathElectric.lineTo(cx + radius/2,cy + radius/4);
    pathElectric.lineTo(cx + 3*radius/4,cy + 3*radius/8);
    pathElectric.lineTo(cx - 3*radius/4,cy + 7*radius/8);
    pathElectric.lineTo(cx - radius/4,cy);
    pathElectric.lineTo(cx - radius/2,cy - radius/4);

    canvas.drawPath(pathElectric,paintElectric);
}

@Override
protected void updateTypesPaints(float currentProgress) {
    if (currentProgress &lt; 0.5f) {
        float progress = (float) Utils.mapValueFromRangeToRange(currentProgress, 0f, 0.5f, 0, 1f);
        paintElectric.setColor((Integer) argbEvaluator.evaluate(progress, COLOR_1, COLOR_2));
    } else {
        float progress = (float) Utils.mapValueFromRangeToRange(currentProgress, 0.5f, 1f, 0, 1f);
        paintElectric.setColor((Integer) argbEvaluator.evaluate(progress, COLOR_2, COLOR_3));

    }
}

@Override
protected void updateTypesAlpha(int alpha) {
    paintElectric.setAlpha(alpha);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;TypeView&lt;/code&gt;设计为抽象类可以让我们在之后绘制新效果时只用关注于具体图案的绘制，实际上目前由于时间关系我只实现了四个属性效果，分别为&lt;code&gt;Electric&lt;/code&gt;,&lt;code&gt;Fire&lt;/code&gt;,&lt;code&gt;Grass&lt;/code&gt;和&lt;code&gt;Water&lt;/code&gt;，而在&lt;code&gt;PokemonType&lt;/code&gt;中我预设了所有的精灵属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum  PokemonType {
    NORMAL,
    FIRE,
    FIGHTING,
    WATER,
    FLYING,
    GRASS,
    POSITION,
    ELECTRIC,
    GROUND,
    PSYCHIC,
    ROCK,
    ICE,
    BUG,
    DRAGON,
    GHOST,
    DARK,
    STEEL,
    FAIRY
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;PokemonButton&lt;/h5&gt;

&lt;p&gt;最终的&lt;code&gt;ViewGroup&lt;/code&gt;由&lt;code&gt;PokeballView&lt;/code&gt;，&lt;code&gt;ImageView&lt;/code&gt;和动态生成的具体实现的&lt;code&gt;TypeView&lt;/code&gt;组成。&lt;/p&gt;

&lt;p&gt;最终的&lt;code&gt;View&lt;/code&gt;动画由一些较小的动画组成，通过&lt;code&gt;AnimatorSet&lt;/code&gt;一起播放：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;animatorSet = new AnimatorSet();

ObjectAnimator outerCircleAnimator = ObjectAnimator.ofFloat(pokeBallView, pokeBallView.OUTER_CIRCLE_RADIUS_PROGRESS, 0.1f, 1f);
outerCircleAnimator.setDuration(250);
outerCircleAnimator.setInterpolator(DECCELERATE_INTERPOLATOR);

ObjectAnimator innerCircleAnimator = ObjectAnimator.ofFloat(pokeBallView, pokeBallView.INNER_CIRCLE_RADIUS_PROGRESS, 0.1f, 1f);
innerCircleAnimator.setDuration(200);
innerCircleAnimator.setStartDelay(200);
innerCircleAnimator.setInterpolator(DECCELERATE_INTERPOLATOR);

ObjectAnimator starScaleYAnimator = ObjectAnimator.ofFloat(icon, ImageView.SCALE_Y, 0.2f, 1f);
starScaleYAnimator.setDuration(350);
starScaleYAnimator.setStartDelay(250);
starScaleYAnimator.setInterpolator(OVERSHOOT_INTERPOLATOR);

ObjectAnimator starScaleXAnimator = ObjectAnimator.ofFloat(icon, ImageView.SCALE_X, 0.2f, 1f);
starScaleXAnimator.setDuration(350);
starScaleXAnimator.setStartDelay(250);
starScaleXAnimator.setInterpolator(OVERSHOOT_INTERPOLATOR);

ObjectAnimator dotsAnimator = ObjectAnimator.ofFloat(typeView, typeView.TYPES_PROGRESS, 0, 1f);
dotsAnimator.setDuration(900);
dotsAnimator.setStartDelay(50);
dotsAnimator.setInterpolator(ACCELERATE_DECELERATE_INTERPOLATOR);

animatorSet.playTogether(
        outerCircleAnimator,
        innerCircleAnimator,
        starScaleYAnimator,
        starScaleXAnimator,
        dotsAnimator
);

animatorSet.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationCancel(Animator animation) {
        pokeBallView.setInnerCircleRadiusProgress(0);
        pokeBallView.setOuterCircleRadiusProgress(0);
        typeView.setCurrentProgress(0);
        icon.setScaleX(1);
        icon.setScaleY(1);
    }
});

animatorSet.start();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;PokemonButton&lt;/code&gt;需要相应点击事件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public boolean onTouchEvent(MotionEvent event) {
    if(!isEnabled)
        return true;

    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            setPressed(true);
            break;

        case MotionEvent.ACTION_MOVE:
            float x = event.getX();
            float y = event.getY();
            boolean isInside = (x &gt; 0 &amp;&amp; x &lt; getWidth() &amp;&amp; y &gt; 0 &amp;&amp; y &lt; getHeight());
            if (isPressed() != isInside) {
                setPressed(isInside);
            }
            break;

        case MotionEvent.ACTION_UP:
            icon.animate().scaleX(0.7f).scaleY(0.7f).setDuration(150).setInterpolator(DECCELERATE_INTERPOLATOR);
            icon.animate().scaleX(1).scaleY(1).setInterpolator(DECCELERATE_INTERPOLATOR);
            if (isPressed()) {
                performClick();
                setPressed(false);
            }
            break;
    }
    return true;
}&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 4</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes4/</link>
      <pubDate>Fri, 16 Dec 2016 18:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes4/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(4)&lt;/p&gt;

&lt;p&gt;Effective Java第5章 泛型&lt;/p&gt;

&lt;h5&gt;23.请不要在新代码中使用原生态类型&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Set&amp;lt;Object&amp;gt;&lt;/code&gt;是个参数化类型，表示可以包含任何对象类型的一个集合；&lt;code&gt;Set&amp;lt;?&amp;gt;&lt;/code&gt;则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；&lt;code&gt;Set&lt;/code&gt;则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。&lt;/p&gt;

&lt;h5&gt;24.消除非受检警告&lt;/h5&gt;

&lt;p&gt;本处主要介绍比较难以消除的警告的示例。&lt;/p&gt;

&lt;p&gt;如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个&lt;code&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/code&gt;注解来禁止这条警告。&lt;strong&gt;应该始终在尽可能小的范围中使用&lt;code&gt;SuppressWarnings&lt;/code&gt;注解，并且每当使用该注解时都要添加一条注释，说明为什么这么做是安全的。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;25.列表优先于数组&lt;/h5&gt;

&lt;p&gt;数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。一般来说，数组和泛型不能很好地混合使用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表代替数组。&lt;/p&gt;

&lt;h5&gt;26.优先考虑泛型&lt;/h5&gt;

&lt;p&gt;看如下一个简单堆栈的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Stack {
    pprivate Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITAL_CAPACITY = 16;
    
    public Stack() {
        elements = new Object[DEFAULT_INITAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if(size == 0) {
            throw new EmptyStackException();
        }
        Object result = elements[--size];
        elements[size] = null;
        return result;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }

    private void ensureCapacity() {
        if(elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将该类泛型化可以提高类型的安全性，方便客户端使用(无需显式强制转换类型)&lt;/p&gt;

&lt;p&gt;用类型参数替换所有的&lt;code&gt;Object&lt;/code&gt;类型：&lt;code&gt;private E[] elements;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于不能创建不可具体化类型的数组，所以会报错&lt;code&gt;generic array creation new E[DEFAULT_INITIAL_CAPACITY]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们有两种解决办法：&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;1.创建一个&lt;code&gt;Object&lt;/code&gt;数组，并将它转换成泛型数组类型：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];&lt;/code&gt;
错误变成一条警告，因为可以保证类型安全，所以可以用&lt;code&gt;SupressWarning&lt;/code&gt;注释忽略掉该警告。&lt;/p&gt;

&lt;p&gt;2.将&lt;code&gt;elements&lt;/code&gt;域的类型从&lt;code&gt;E[]&lt;/code&gt;改为&lt;code&gt;Object[]&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object[] elements;

E result = (E) elements[--size];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;产生一条警告，因为可以保证类型安全，所以可以用&lt;code&gt;SupressWarning&lt;/code&gt;注释忽略掉该警告。&lt;/p&gt;

&lt;p&gt;这两种方法，一般来说禁止数组类型的未受检转换比禁止标题类型更危险，所以建议使用第二种方法。但是在比这个例子更实际的泛型中，或许代码中会有多个地方需要从数组中读取元素，因此第一种方法比第二种方法开销更小一些，这也是第一种方法更常用的原因。这个例子看起来违反了&lt;code&gt;25&lt;/code&gt;条(它告诉我们对于泛型列表要优于数组)，实际上因为&lt;code&gt;Java&lt;/code&gt;并不是生来就支持列表，所以有些泛型如&lt;code&gt;ArrayList&lt;/code&gt;必须使用数组来实现，有的时候为了提升性能，也会考虑用数组来实现，比如&lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;总之，使用泛型比使用需要在客户端代码中进行转化的类型来的更安全。也更容易，在设计新类的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成是泛型的。&lt;/p&gt;

&lt;h5&gt;27.优先考虑泛型方法&lt;/h5&gt;

&lt;p&gt;考虑如下的方法，它的作用是返回两个集合的联合：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Set union(Set s1, Set s2) {  
    Set result = new HashSet(s1);  
    result.addAll(s2);  
    return result;  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译这段代码会产生警告，为了修正这些警告(在新代码中不应该直接使用原始类型，当前是为了举例子)要将方法声名修改为声明一个类型参数，表示这三个元素类型(两个参数及一个返回值)，并在方法中使用类型参数。声名类型参数的类型参数列表，处在方法的修饰符及其返回类型之间，修改后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;E&gt; Set&amp;lt;E&gt; union(Set&amp;lt;E&gt; s1, Set&amp;lt;E&gt; s2) {  
    Set&amp;lt;E&gt; result = new HashSet&amp;lt;E&gt;(s1);  
    result.addAll(s2);  
    return result;  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前这个版本的&lt;code&gt;union&lt;/code&gt;方法即为一般的泛型方法，但是它有一个限制，要求三个集合的类型(两个输入参数及一个返回值)必须全部相同。利用有限制的通配符类型可以使这个方法变得更回灵活。&lt;/p&gt;

&lt;p&gt;泛型方法的一个显著特征是，无需明确指定类型参数的值，不像调用泛型构造器的时候是必须要指定类型参数的，在为泛型方法的类型会存在一个类型推导的过程。编译器通过检查方法参数的类型来计算类型的值。在调用 泛型构造器的时候，要明确传递类型参数的值可能有点麻烦。类型参数出现在了变量的声明的左右两边，显得冗余：&lt;code&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于这情况，可以遵照第&lt;code&gt;1&lt;/code&gt;条，提供一个静态工厂方法来简化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;K, V&gt; HashMap&amp;lt;K, V&gt; newHashMap() {  
    return new HashMap&amp;lt;K, V&gt;();  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用上面的静态工厂方法，我们可以把变量声明右侧的参数类型省略掉，当参数类型多而复杂时尤其有效。&lt;/p&gt;

&lt;p&gt;有时会需要创建不可变但是又适合于许多不同类型的对象，由于泛型是通过擦除来实现的，可以给所有的必要的类型参数使用同一个单个对象，但是需要一个静态的工厂方法来给每个必要的类型参数分发对象。这种模式叫做&amp;rdquo;泛型单例工厂&amp;rdquo;，这种模式最常用于函数的对象。假设有一个接口，描述了一个方法，该方法接受和返回某个类型&lt;code&gt;T&lt;/code&gt;的值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UnaryFunction&amp;lt;T&gt; {  
    T apply(T arg);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在假设要提供一个恒等函数，如果 在每次需要的时候都重新创建一个这样会很浪费，因为它是无状态的。如果泛型被具体化，那个每个类型都必须持有相应类型的恒等函数，但是在运行时擦除类型信息后，它们并没有什么区别，所以在这种情况下，只需要一个泛型单例就够了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static UnaryFunction
 INDENTITY_FUNCTION = new UnaryFunction {
    public Object apply(Object arg) { return arg; }  
}; 

@SuppressWarnings(&#34;unchecked&#34;)
public static  UnaryFunction indentityFunction() {
    return (UnaryFunction)INDENTITY_FUNCTION;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归类型限制最普遍的用途与&lt;code&gt;Comparable&lt;/code&gt;接口有关，它定义类型的自然顺序。许多方法都带有一个实现&lt;code&gt;Comparable&lt;/code&gt;接口的元素列表，为了对列表进行排序，并在其中进行搜索，计算出它的最小值或者最大值等等。要完成这其中的任何一项工作要求列表中的每个元素都能够与列表中的其他元素相比较，一个示例：&lt;code&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list) {  }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的声名要求&lt;code&gt;T&lt;/code&gt;是可以与自身同类型对象相比较的类型，&lt;code&gt;extends&lt;/code&gt;可以解释为&amp;rdquo;实现某功能&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;总之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来的更加安全，也更加容易。就像类型一样，你应该确保新的方法可以不用转换就能使用，这通常意味着要将它们泛型化。并且就像类型一样，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会破坏现有的客户端。&lt;/p&gt;

&lt;h5&gt;28.利用有限制通配符来提升API的灵活性&lt;/h5&gt;

&lt;p&gt;为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。&lt;code&gt;PESC&lt;/code&gt;表示&lt;code&gt;producter-extends&lt;/code&gt;, &lt;code&gt;consumer-super&lt;/code&gt;。如果参数化类型表示一个&lt;code&gt;T&lt;/code&gt;生产者，就使用&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;；如果它表示一个&lt;code&gt;T&lt;/code&gt;消费者，就使用&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果类型参数只在方法声明中出现一次，就可以用通配符取代它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void swap(List&amp;lt;?&gt; list, int i, int j) {  
    swapHelper(list, i, j);  
}  
  
private static &amp;lt;E&gt; void swapHelper(List&amp;lt;E&gt; list, int i, int j) {  
    list.set(i, list.set(j, list.get(i)));  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;所有的&lt;code&gt;comparable&lt;/code&gt;和&lt;code&gt;comparator&lt;/code&gt;都是消费者。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;29.优先考虑类型安全的异构容器&lt;/h5&gt;

&lt;p&gt;有时会需要未限定固定数目的类型参数的容器，此时，可以将容器的键进行参数化而不是将容器参数化。然后将参数化的键交给容器来插入或者获得值。用泛型系统来确保值的类型和它的键相符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ManyTypeClass
{
    //一个存放数据的容器,由于键值类型是不确定的，那么值类型就只能是object类型
    private Map&amp;lt;Class&amp;lt;?&gt;, Object&gt; data = new HashMap&amp;lt;Class&amp;lt;?&gt;, Object&gt;();
    
    public &amp;lt;T&gt; void putData(Class&amp;lt;T&gt; type, T instance)
    {
        //吧数据放入进去
        if(type != null)
        {
            //这里需要进行一下类型转换，通过Class的cast方法，因为泛型是基于擦除的，如果不进行验证的话，那么插入的数据到底是不是真的type类型就无法确定的了
            data.put(type, type.cast(instance));
        }
    }
    
    public &amp;lt;T&gt; T getDate(Class&amp;lt;T&gt; type)
    {
        //取出数据,由于数据存放进去是object类型的，那么取出来的时候就需要进行一次类型转换
        return type.cast(data.get(type));
    }
    
    public static void main(String[] args)
    {
        ManyTypeClass mtc = new ManyTypeClass();
        mtc.putData(String.class, &#34;cutter_point&#34;);
        mtc.putData(Integer.class, 0xcab145de);
        mtc.putData(Class.class, ManyTypeClass.class);
        mtc.putData(ManyTypeClass.class, mtc);
        
        String dataString = mtc.getDate(String.class);
        int dataInteger = mtc.getDate(Integer.class);
        Class&amp;lt;?&gt; dataClass = mtc.getDate(Class.class);
        ManyTypeClass mtc1 = mtc.getDate(ManyTypeClass.class);
        
        System.out.printf(&#34;%s %x %s %s%n&#34;, dataString,
                dataInteger, dataClass.getName(), mtc1.getDate(String.class));
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能存储&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;。因为在运行时他们的类型会被擦除，所以&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;与&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;实际上是共用一个Class。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 3</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes3/</link>
      <pubDate>Fri, 16 Dec 2016 14:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes3/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(3)&lt;/p&gt;

&lt;p&gt;Effective Java第4章 类和接口&lt;/p&gt;

&lt;h5&gt;13.使类和成员的可访问性最小化&lt;/h5&gt;

&lt;p&gt;访问控制机制决定了类、接口和成员的可访问性。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符共同决定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尽可能地使每个类或者成员不被外界访问。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;私有的&lt;code&gt;private&lt;/code&gt;——只有在声明该成员的顶层类内部才可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包级私有的&lt;code&gt;package-private/default&lt;/code&gt;——声明该成员的包内部的任何类都可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;受保护的&lt;code&gt;protected&lt;/code&gt;——声明该成员的类的子类可以访问这个成员（有一些限制），并且，声明该成员的包内部的任何类也可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;公有的&lt;code&gt;public&lt;/code&gt;——在任何地方都可以访问该成员。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现了Serializable接口的类的私有域可能会被“泄漏”。&lt;/p&gt;

&lt;p&gt;子类中的访问级别不允许低于超类中的访问级别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;除了公有静态final域的特殊情形之外，公有类都不应该包含公有域。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;14.在公有类中使用访问方法而非公有域&lt;/h5&gt;

&lt;p&gt;如果类可以在它所在的包的外部进行访问，就提供访问方法。公有类永远都不应该暴露可变的域。但是，有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变还是不可变的。&lt;/p&gt;

&lt;h5&gt;15.使可变性最小化&lt;/h5&gt;

&lt;p&gt;不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。&lt;/p&gt;

&lt;p&gt;为了使类成为不可变，要遵循下面五条规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要提供任何会修改对象状态的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保证类不会被扩展。一般使类成为&lt;code&gt;final&lt;/code&gt;，但后面还会讨论其他做法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使所有的域都是&lt;code&gt;final&lt;/code&gt;的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使所有的域都成为私有的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确保对于任何可变组件的互斥访问。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不可变对象本质上是线程安全的，它们不要求同步；不仅可以共享不可变对象，甚至也可以共享它们的内部信息；不可以对象为其他对象提供了大量的构件。&lt;strong&gt;不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让不可变的类变成&lt;code&gt;final&lt;/code&gt;的另一种方法就是，让类的所有构造器都变成私有的或者包级私有的，并添加公有的静态工厂来代替公有的构造器。&lt;/p&gt;

&lt;h5&gt;*16.复合优先于继承&lt;/h5&gt;

&lt;p&gt;继承打破了封装性，子类依赖于其超类中特定功能的实现细节。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。&lt;/p&gt;

&lt;p&gt;为了避免继承导致的脆弱性，我们可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {
    private final Set&lt;E&gt; s;

    public ForwardingSet(Set&lt;E&gt; s) {
        this.s = s;
    }

    public void clear() {
        s.clear();
    }

    public boolean contains(Object o) {
        return s.contains(o);
    }

    public boolean isEmpty() {
        return s.isEmpty();
    }

    public int size() {
        return s.size();
    }

    public Iterator&lt;E&gt; iterator() {
        return s.iterator();
    }

    public boolean add(E e) {
        return s.add(e);
    }

    public boolean remove(Object o) {
        return s.remove(o);
    }

    public boolean containsAll(Collection&lt;?&gt; c) {
        return s.containsAll(c);
    }

    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return s.addAll(c);
    }

    public boolean removeAll(Collection&lt;?&gt; c) {
        return s.removeAll(c);
    }

    public boolean retainAll(Collection&lt;?&gt; c) {
        return s.retainAll(c);
    }

    public Object[] toArray() {
        return s.toArray();
    }

    public &lt;T&gt; T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}

public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {
    private int addCount = 0;

    public InstrumentedSet(Set&lt;E&gt; s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;17.要么为继承而设计，并提供文档说明，要么就禁止继承&lt;/h5&gt;

&lt;p&gt;为继承而设计的类必须有文档说明它可覆盖&lt;code&gt;overridable&lt;/code&gt;的方法的自用性，且必须通过某种形式提供适当的钩子&lt;code&gt;hook&lt;/code&gt;，以便能够进入到它的内部工作流程中，这种形式可以使精心选择的受保护&lt;code&gt;protected&lt;/code&gt;的方法，也可以是受保护的域，后者比较少见。该类的唯一的测试方法就是编写子类。&lt;/p&gt;

&lt;p&gt;为了允许继承，类还必须遵守其他一些约束。&lt;strong&gt;构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;18.接口优于抽象类&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现有的类可以很容易被更新，以实现新的接口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口是定义&lt;code&gt;mixin(混合类型)&lt;/code&gt;的理想选择。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口允许我们构造非层次结构的类型框架。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抽象类的演变比接口的演变要容易得多。&lt;strong&gt;接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;19.接口只用于定义类型&lt;/h5&gt;

&lt;p&gt;接口应该只被用来定义类型，不应该被用来导出常量，导出常量可以使用枚举类型和不可实例化的工具类。&lt;/p&gt;

&lt;h5&gt;20.类层次优于标签类&lt;/h5&gt;

&lt;p&gt;标签类过于冗长、容易出错，并且效率低下。标签类很少有适用的时候，当你想要编写一个包含显式标签域的类时，应该考虑一下这个标签是否可以被取消，这个类是否可以使用类层次来代替。&lt;/p&gt;

&lt;p&gt;以下为一个标签类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Figure {  
    enum Shape { RECTANGLE, CIRCLE };  
  
    // Tag field - the shape of this figure  
    final Shape shape;  
  
    // These fields are used only if shape is RECTANGLE  
    double length;  
    double width;  
  
    // This field is used only if shape is CIRCLE  
    double radius;  
  
    // Constructor for circle  
    Figure(double radius) {  
        shape = Shape.CIRCLE;  
        this.radius = radius;  
    }  
  
    // Constructor for rectangle  
    Figure(double length, double width) {  
        shape = Shape.RECTANGLE;  
        this.length = length;  
        this.width = width;  
    }  
  
    double area() {  
        switch(shape) {  
          case RECTANGLE:  
            return length * width;  
          case CIRCLE:  
            return Math.PI * (radius * radius);  
          default:  
            throw new AssertionError();  
        }  
    }  
}&lt;/code&gt;&lt;/pre&gt;  

&lt;p&gt;修改后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class Figure {  
    abstract double area();  
}  
class Circle extends Figure {  
    final double radius;  
  
    Circle(double radius) { this.radius = radius; }  
  
    double area() { return Math.PI * (radius * radius); }  
}  
class Rectangle extends Figure {  
    final double length;  
    final double width;  
  
    Rectangle(double length, double width) {  
        this.length = length;  
        this.width  = width;  
    }  
    double area() { return length * width; }  
}  
class Square extends Rectangle {  
    Square(double side) {  
        super(side, side);  
    }  
}&lt;/code&gt;&lt;/pre&gt;  

&lt;h5&gt;21.用函数对象表示策略&lt;/h5&gt;

&lt;p&gt;函数指针的主要用途就是实现策略模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体的策略只被使用一次时，通常使用匿名内部类来声明和实例化这个具体策略类。当一个具体策略被设计用来重复使用的时候，它的类通常要被实现为私有的静态成员，并通过公有的静态final域被导出，其类型为该策略接口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Arrays.sort(StringArray,new Comparator&lt;String&gt;(){
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Host {
    private static class StrLenCmp implements Comparator&lt;String&gt;,Serializable{
 
        @Override
        public int compare(String s1, String s2) {
            return s1.length() - s2.length();
        }
    }
     
    public static final Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = new StrLenCmp();
     
    public static void main(String[] args) {
        String s1 = &#34;&#34;;
        String s2 = &#34;&#34;;
        int result = Host.STRING_LENGTH_COMPARATOR.compare(s1, s2);
        System.out.println(result);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;22.优先考虑静态成员类&lt;/h5&gt;

&lt;p&gt;嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。如果嵌套类将来可能会用于其他的某个环境中，他就应该是顶层类。嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类。除了第一种之外，其他三种都称为内部类。&lt;/p&gt;

&lt;p&gt;从语法上讲，静态成员类和非静态成员类之间的唯一区别是，静态成员类的声明中包含修饰符&lt;code&gt;static&lt;/code&gt;。尽管他们的语法非常相似，但是两种嵌套类有很大的不同。非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修改过的&lt;code&gt;this&lt;/code&gt;构造获得外围实例的引用。如果嵌套类的实例可以在他外围类的实力之外独立存在，这个嵌套类就必须是静态成员类，在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。&lt;/p&gt;

&lt;p&gt;当非静态成员类的实例被创建的时候，他和外围之间的关联关系也随之被创立起来；而且，这种关联关系以后不能被修改。通常情况下，当在外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关系被自动建立起来。
使用表达式enclosingInstance.new MemberClass(args)来手工建立这种关联关系也是有可能的，但是很少使用。正如你所预料的那样，这种关联关系需要消耗费静态成员类的实例空间，并且构造的时间开销。&lt;/p&gt;

&lt;p&gt;如果声明成员类不要求访问外围实例，就要始终把&lt;code&gt;static&lt;/code&gt;修饰符放在他的声明中。&lt;/p&gt;

&lt;p&gt;匿名类的三种常见用法：1.动态的创建函数对象，如&lt;code&gt;sort&lt;/code&gt;方法的调用利用了匿名的&lt;code&gt;Comparator&lt;/code&gt;实例；2.创建过程对象，如&lt;code&gt;Runnable&lt;/code&gt;、&lt;code&gt;Thread&lt;/code&gt;或者&lt;code&gt;TimerTask&lt;/code&gt;实例；3.在静态工厂方法的内部使用。&lt;/p&gt;

&lt;p&gt;如果一个嵌套类需要在单个方法之外仍然是可见的，或者他太长了，不适合方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则就做成静态的。假设这个嵌套类属于一个方法的内部，如果你需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就把他做成匿名类；否则，就做成局部类。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 2</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</link>
      <pubDate>Thu, 15 Dec 2016 19:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(2)&lt;/p&gt;

&lt;p&gt;Effective Java第3章 对于所有对象都通用的方法&lt;/p&gt;

&lt;h5&gt;8.覆盖equals时请遵守通用约定&lt;/h5&gt;

&lt;p&gt;覆盖&lt;code&gt;Object.equals&lt;/code&gt;的时机：类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖&lt;code&gt;equals&lt;/code&gt;以实现期望的行为。这通常属于“值类”的情形，有一种“值类”不需要覆盖&lt;code&gt;equals&lt;/code&gt;方法，即用实例受控确保“每个值至多只存在一个对象”的类，比如枚举类型。&lt;/p&gt;

&lt;p&gt;在覆盖&lt;code&gt;equals&lt;/code&gt;方法的时候，你必须要遵守它的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自反性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x.equals(x)&lt;/code&gt;必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对称性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;，当且仅当&lt;code&gt;y.equals(x)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;时，&lt;code&gt;x.equals(y)&lt;/code&gt;必须返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传递性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x、y和z&lt;/code&gt;，如果&lt;code&gt;x.equals(y)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;，并且&lt;code&gt;y.equals(z)&lt;/code&gt;也返回&lt;code&gt;true&lt;/code&gt;，那么&lt;code&gt;x.equals(z)&lt;/code&gt;也必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一致性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x和y&lt;/code&gt;，只要&lt;code&gt;equals&lt;/code&gt;的比较操作在对象中所用的信息没有被修改，多次调用&lt;code&gt;x.equals(y)&lt;/code&gt;就会一致地返回&lt;code&gt;true&lt;/code&gt;，或者一致地返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于任何非null的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x,equals(null)&lt;/code&gt;必须返回false。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现高质量&lt;code&gt;equals&lt;/code&gt;方法的诀窍：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;==&lt;/code&gt;操作符检查“参数是否为这个对象的引用”。如果是，则返回&lt;code&gt;true&lt;/code&gt;。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;instanceof&lt;/code&gt;操作符检查“参数是否为正确的类型”。如果不是，则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把参数转换成正确的类型。因为转换前进行过&lt;code&gt;instanceof&lt;/code&gt;测试，所以确保会成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于既不是&lt;code&gt;float&lt;/code&gt;也不是&lt;code&gt;double&lt;/code&gt;类型的基本类型域，可以使用&lt;code&gt;==&lt;/code&gt;操作符进行比较，对于对象引用域，可以递归地调用&lt;code&gt;equals&lt;/code&gt;方法；对于&lt;code&gt;float&lt;/code&gt;域，可以使用&lt;code&gt;Float.compare&lt;/code&gt;方法；对于&lt;code&gt;double&lt;/code&gt;域，则使用&lt;code&gt;Double.compare&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;9.覆盖equals时总要覆盖hashCode&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Object.hashCode&lt;/code&gt;的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在应用程序的执行期间，只要对象的&lt;code&gt;equals&lt;/code&gt;方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次,&lt;code&gt;hashCode&lt;/code&gt;方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法都必须产生同样的整数结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是不相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;10.始终要覆盖toString&lt;/h5&gt;

&lt;p&gt;提供好的&lt;code&gt;toString&lt;/code&gt;实现可以使类用起来更加舒适，在实际应用中，&lt;code&gt;toString&lt;/code&gt;方法应该返回对象中包含的所有值得关注的信息。&lt;/p&gt;

&lt;h5&gt;11.谨慎地覆盖clone&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Clone&lt;/code&gt;方法的通用约定：
对于任何对象&lt;code&gt;x&lt;/code&gt;，表达式&lt;code&gt;x.clone() != x&lt;/code&gt; 将会是&lt;code&gt;true&lt;/code&gt;，并且，表达式&lt;code&gt;x.clone().getClass() == x.getClass()&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但这些都不是绝对的要求。虽然通常情况下，表达式&lt;code&gt;x.clone().equals(x)&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但是，这也不是一个绝对的要求。拷贝对象往往会导致创建它的类的一个新实例，但它同时也会要求拷贝内部的数据结构。这个过程中没有调用构造器。&lt;/p&gt;

&lt;p&gt;所有实现了&lt;code&gt;Cloneable&lt;/code&gt;接口的类都应该用一个公有的方法覆盖&lt;code&gt;clone&lt;/code&gt;。此公有方法首先调用&lt;code&gt;super.clone&lt;/code&gt;，然后修正任何需要修正的域。一般情况下，这意味着要拷贝任何包含内部“深层结构”的可变对象，并用指向新对象的引用代替原来指向这些对象的引用。虽然，这些内部拷贝操作往往可以通过递归地调用&lt;code&gt;clone&lt;/code&gt;来完成，但这通常并不是最佳方法。如果该类只包含基本类型的域，或者指向不可变对象的引用，那么多半的情况是没有域需要修正。这条规则也有例外，譬如，代表序列号或其他唯一ID值得域，或者代表对象的创建时间的域，不管这些域是基本类型还是不可变的，它们也都需要被修正。&lt;/p&gt;

&lt;p&gt;另一个实现对象拷贝的好办法是提供一个拷贝构造器或拷贝工厂。拷贝构造器只是一个构造器，它唯一的参数类型是包含该构造器的类。如&lt;code&gt;public Go(Go go);&lt;/code&gt;，拷贝工厂是类似于拷贝构造器的静态工厂&lt;code&gt;public static Go newInstance(Go go);&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;12.考虑实现Comparable接口&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;compareTo&lt;/code&gt;方法的通用约定：&lt;/p&gt;

&lt;p&gt;讲这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。&lt;/p&gt;

&lt;p&gt;在下面的说明中，符号&lt;code&gt;sgn&lt;/code&gt;表示数学中的&lt;code&gt;signum&lt;/code&gt;函数，它根据表达式的值为负值、零和正值，分别返回-1、0或1。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实现者必须确保所有的&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(y)) == -sgn(y.compareTo(x))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现者还必须确保这个比较关系是可传递的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，实现者必须确保&lt;code&gt;x.compareTo(y) == 0&lt;/code&gt;暗示着所有的&lt;code&gt;z&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强烈建议&lt;code&gt;(x.compareTo(y) == 0) == (x.equals(y))&lt;/code&gt;，但这并非绝对必要。一般说来，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有内在的排序功能，但是与equals不一致。”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 1</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</link>
      <pubDate>Thu, 15 Dec 2016 16:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(1)&lt;/p&gt;

&lt;p&gt;Effective Java第2章 创建和销毁对象&lt;/p&gt;

&lt;h5&gt;1.考虑用静态工厂方法代替构造器&lt;/h5&gt;

&lt;p&gt;静态工厂方法相较于构造器有四大优势：（1）它们有名称；（2）不必在每次调用它们的时候都创建一个新对象；（3）它们可以返回原返回类型的任何子类型的对象；（4）在创建参数化类型实例时，它们使代码变得更加简洁。两大缺点：（1）类如果不含公有的或受保护的构造器，就不能被子类化；（2）它们与其他的静态方法实际上并没有任何区别。&lt;/p&gt;

&lt;h5&gt;2.遇到多个构造器参数时要考虑用构建器&lt;/h5&gt;

&lt;p&gt;一个很直观的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;

    public static class Builder {
        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;

        public Builder(int servingSize, int servings){
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val){
            calories = val;
            return this;
        }

        public Builder fat(int val){
            fat = val;
            return this;
        }

        public NutritionFacts build(){
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder){
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要创建一个实例时只需根据自己的需要添加参数&lt;code&gt;NutritionFacts cocaCola = new Builder(240,8).calories(100).build();&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;3.用私有构造器或者枚举类型强化Singleton属性&lt;/h5&gt;

&lt;p&gt;除了非常常见的两种单例实现方法外，在Java 1.5之后我们有了一个更好的选择，使用单元素枚举类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum SingleTon {
    INSTANCE;
    public void orz() {
        //blablabla
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后如此调用&lt;code&gt;SingleTon s1 = SingleTon.INSTANCE;s1.orz();&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;4.通过私有构造器强化不可实例化的能力&lt;/h5&gt;

&lt;p&gt;对于一些只包含静态方法和静态域的工具类，我们不希望它被实例化，可以通过以下方式进行强化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UtilityClass{
    //Suppress default constructor for moninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;5.避免创建不必要的对象&lt;/h5&gt;

&lt;p&gt;一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。&lt;/p&gt;

&lt;p&gt;对于可重用的对象可以通过使用一个静态的初始化器&lt;code&gt;static{}&lt;/code&gt;来创建以避免重复创建，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。维护自己的对象池来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的，其中一个典型示例为数据库连接池。&lt;/p&gt;

&lt;h5&gt;6.消除过期的对象引用&lt;/h5&gt;

&lt;p&gt;要警惕内存泄漏问题，及时清除过期引用，使用合适的数据结构保存缓存、监听器以及其他回调，例如&lt;code&gt;WeakReference&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;7.避免使用终结方法&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;finalizer&lt;/code&gt;通常是不可预测的，也是很危险的，一般情况下是不必要的，并且该方法会导致严重的性能损失。如果类的对象中封装的资源确实需要终止，我们应该提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。终结方法有两种合法用途：1、充当&amp;rdquo;安全网&amp;rdquo;；2、终止非关键的本地资源。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Memory Leak</title>
      <link>https://gaogggg.github.io/post/android/android-memory-leak/</link>
      <pubDate>Wed, 14 Dec 2016 18:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/android/android-memory-leak/</guid>
      <description>&lt;p&gt;Android内存泄漏总结&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;h4&gt;基础知识&lt;/h4&gt;
&lt;br&gt;
&lt;h5&gt;1)泄露的对象&lt;/h5&gt;&lt;/p&gt;

&lt;p&gt;首先我们来了解程序运行时，所需内存的分配策略：&lt;/p&gt;

&lt;p&gt;按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、堆区和栈区。他们的功能不同，对他们使用方式也就不同。&lt;/p&gt;

&lt;p&gt;静态存储区（方法区）：内存在程序编译的时候就已经分配好，这块内存在程序整个运行期间都存在。它主要存放静态数据、全局&lt;code&gt;static&lt;/code&gt;数据和常量。&lt;/p&gt;

&lt;p&gt;栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。&lt;/p&gt;

&lt;p&gt;堆区：亦称动态内存分配。程序在运行的时候用&lt;code&gt;malloc&lt;/code&gt;或&lt;code&gt;new&lt;/code&gt;申请任意大小的内存，程序员自己负责在适当的时候用&lt;code&gt;free&lt;/code&gt;或&lt;code&gt;delete&lt;/code&gt;释放内存（&lt;code&gt;JAVA&lt;/code&gt;则依赖垃圾回收器）。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉。&lt;/p&gt;

&lt;p&gt;接下来我们集中说下堆和栈的区别：&lt;/p&gt;

&lt;p&gt;在函数中（说明是局部变量）定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，&lt;code&gt;JAVA&lt;/code&gt;就在栈中为这个变量分配内存空间，当超过变量的作用域后，&lt;code&gt;JAVA&lt;/code&gt;会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。&lt;/p&gt;

&lt;p&gt;堆内存用于存放所有由&lt;code&gt;new&lt;/code&gt;创建的对象（内容包括该对象其中的所有成员变量）和数组。在堆中分配的内存，由&lt;code&gt;JAVA&lt;/code&gt;虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。&lt;/p&gt;

&lt;p&gt;堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（&lt;code&gt;32bit&lt;/code&gt;系统理论上是4G），所以堆的空间比较灵活，比较大。栈是一块连续的内存区域，大小是操作系统预定好的，&lt;code&gt;windows&lt;/code&gt;下栈大小是&lt;code&gt;2M&lt;/code&gt;（也有是&lt;code&gt;1M&lt;/code&gt;，在编译时确定，&lt;code&gt;VC&lt;/code&gt;中可设置）。&lt;/p&gt;

&lt;p&gt;对于堆，频繁的&lt;code&gt;new/delete&lt;/code&gt;会造成大量内存碎片，使程序效率降低。对于栈，它是先进后出的队列，进出一一对应，不产生碎片，运行效率稳定高。&lt;/p&gt;

&lt;h5&gt;结论：&lt;/h5&gt;&lt;br&gt;

&lt;strong&gt;局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。&lt;br&gt;——因为它们属于方法中的变量，生命周期随方法而结束。&lt;br&gt;成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）&lt;br&gt;——因为它们属于类，类对象终究是要被&lt;code&gt;new&lt;/code&gt;出来使用的。&lt;br&gt;我们这里说的内存泄露，是针对，也只针对堆内存，他们存放的就是引用指向的对象实体。&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;

&lt;h5&gt;2)泄露的原因&lt;/h5&gt;

&lt;p&gt;为了判断&lt;code&gt;JAVA&lt;/code&gt;中是否有内存泄露，我们首先必须了解&lt;code&gt;JAVA&lt;/code&gt;是如何管理（堆）内存的。&lt;code&gt;JAVA&lt;/code&gt;的内存管理就是对象的分配和释放问题。在&lt;code&gt;JAVA&lt;/code&gt;中，内存的分配是由程序完成的，而内存的释放是由垃圾收集器&lt;code&gt;Garbage Collection,GC&lt;/code&gt;完成的，程序员不需要通过调用函数来释放内存，但它只能回收无用并且不再被其它对象引用的那些对象所占用的空间。&lt;/p&gt;

&lt;p&gt;Java的内存垃圾回收机制是从程序的主要运行对象(如静态对象/寄存器/栈上指向的堆内存对象等)开始检查引用链，当遍历一遍后得到上述这些无法回收的对象和他们所引用的对象链，组成无法回收的对象集合，而其他孤立对象（集）就作为垃圾回收。&lt;code&gt;GC&lt;/code&gt;为了能够正确释放对象，必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，&lt;code&gt;GC&lt;/code&gt;都需要进行监控。监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;JAVA&lt;/code&gt;中，这些无用的对象都由&lt;code&gt;GC&lt;/code&gt;负责回收，因此程序员不需要考虑这部分的内存泄露。虽然，我们有几个函数可以访问&lt;code&gt;GC&lt;/code&gt;，例如运行&lt;code&gt;GC&lt;/code&gt;的函数&lt;code&gt;System.gc()&lt;/code&gt;，但是根据&lt;code&gt;JAVA&lt;/code&gt;语言规范定义，该函数不保证&lt;code&gt;JVM&lt;/code&gt;的垃圾收集器一定会执行。因为不同的&lt;code&gt;JVM&lt;/code&gt;实现者可能使用不同的算法管理&lt;code&gt;GC&lt;/code&gt;。通常&lt;code&gt;GC&lt;/code&gt;的线程的优先级别较低。&lt;code&gt;JVM&lt;/code&gt;调用&lt;code&gt;GC&lt;/code&gt;的策略也有很多种，有的是内存使用到达一定程度时，&lt;code&gt;GC&lt;/code&gt;才开始工作，也有定时执行的，有的是平缓执行&lt;code&gt;GC&lt;/code&gt;，有的是中断式执行&lt;code&gt;GC&lt;/code&gt;。但通常来说，我们不需要关心这些。&lt;/p&gt;

&lt;p&gt;至此，我们来看看&lt;code&gt;JAVA&lt;/code&gt;中需要被回收的垃圾：
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;｛
Person p1 = new Person();
……
｝&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;引用句柄&lt;code&gt;p1&lt;/code&gt;的作用域是从定义到&lt;code&gt;}&lt;/code&gt;处，执行完这对大括号中的所有代码后，产生的&lt;code&gt;Person&lt;/code&gt;对象就会变成垃圾，因为引用这个对象的句柄&lt;code&gt;p1&lt;/code&gt;已超过其作用域，&lt;code&gt;p1&lt;/code&gt;失效，在栈中被销毁，因此堆上的&lt;code&gt;Person&lt;/code&gt;对象不再被任何句柄引用了。 因此&lt;code&gt;person&lt;/code&gt;变为垃圾，会被回收。&lt;/p&gt;

&lt;p&gt;从上面的例子和解释，可以看到一个很关键的词：引用。&lt;/p&gt;

&lt;p&gt;通俗的讲，通过&lt;code&gt;A&lt;/code&gt;能调用并访问到&lt;code&gt;B&lt;/code&gt;，那就说明&lt;code&gt;A&lt;/code&gt;持有&lt;code&gt;B&lt;/code&gt;的引用，或&lt;code&gt;A&lt;/code&gt;就是&lt;code&gt;B&lt;/code&gt;的引用，&lt;code&gt;B&lt;/code&gt;的引用计数&lt;code&gt;+1&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;比如&lt;code&gt;Person p1 = new Person();&lt;/code&gt;通过&lt;code&gt;p1&lt;/code&gt;能操作&lt;code&gt;Person&lt;/code&gt;对象，因此&lt;code&gt;p1&lt;/code&gt;是&lt;code&gt;Person&lt;/code&gt;的引用；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比如类&lt;code&gt;O&lt;/code&gt;中有一个成员变量是&lt;code&gt;I&lt;/code&gt;类对象，因此我们可以使用&lt;code&gt;o.i&lt;/code&gt;的方式来访问I类对象的成员，因此&lt;code&gt;o&lt;/code&gt;持有一个&lt;code&gt;i&lt;/code&gt;对象的引用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;GC&lt;/code&gt;过程与对象的引用类型是严重相关的，我们来看看&lt;code&gt;JAVA&lt;/code&gt;对引用的分类&lt;code&gt;Strong reference, SoftReference, WeakReference, PhatomReference&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://Gaogggg.github.io/post/android/reference_table.png&#34; alt=&#34;强弱软虚引用表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Android&lt;/code&gt;应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。讲多一步，这里的软引用/弱引用一般是做什么的呢？&lt;/p&gt;

&lt;p&gt;软/弱引用可以和一个引用队列&lt;code&gt;ReferenceQueue&lt;/code&gt;联合使用，如果软引用所引用的对象被垃圾回收器回收，&lt;code&gt;Java&lt;/code&gt;虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。&lt;/p&gt;

&lt;p&gt;假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生&lt;code&gt;OutOfMemory&lt;/code&gt;异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CacheBySoftRef {
    
    // 首先定义一个HashMap，保存软引用对象。

    private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt;imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();

    // 再来定义一个方法，保存Bitmap的软引用到HashMap。

    public void addBitmapToCache(String path) {

        // 强引用的Bitmap对象

        Bitmap bitmap = BitmapFactory.decodeFile(path);

        // 软引用的Bitmap对象

        SoftReference&lt;Bitmap&gt;softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);

        // 添加该对象到Map中使其缓存

        imageCache.put(path, softBitmap);

    }

    // 获取的时候，可以通过SoftReference的get()方法得到Bitmap对象。

    public Bitmap getBitmapByPath(String path) {

        // 从缓存中取软引用的Bitmap对象

        SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);

        // 判断是否存在软引用

        if (softBitmap == null) {

            return null;

        }

        // 通过软引用取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空 ，如果未被回收，则可重复使用，提高速度。

        Bitmap bitmap = softBitmap.get();

        return bitmap;

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用软引用以后，在&lt;code&gt;OutOfMemory&lt;/code&gt;异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免&lt;code&gt;Crash&lt;/code&gt;发生。&lt;/p&gt;

&lt;p&gt;如果只是想避免&lt;code&gt;OutOfMemory&lt;/code&gt;异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。&lt;/p&gt;

&lt;p&gt;另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。&lt;/p&gt;

&lt;p&gt;回到我们的问题，为什么内存会泄露？&lt;br&gt;&lt;br&gt;
&lt;strong&gt;堆内存中的长生命周期的对象持有短生命周期对象的强/软引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是&lt;code&gt;Java&lt;/code&gt;中内存泄露的根本原因。&lt;/strong&gt;
&lt;hr&gt;&lt;/p&gt;

&lt;p&gt;&lt;h4&gt;常见原因及实践&lt;/h4&gt;&lt;br&gt;
&lt;h5&gt;常见原因&lt;/h5&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;集合类&lt;/p&gt;

&lt;p&gt;集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 &lt;code&gt;map&lt;/code&gt; 等即有静态引用或 &lt;code&gt;final&lt;/code&gt; 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单例模式&lt;/p&gt;

&lt;p&gt;不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在 &lt;code&gt;JVM&lt;/code&gt; 的整个生命周期中存在(以静态变量的方式)，如果单例对象持有外部对象的引用，那么这个外部对象将不能被 &lt;code&gt;JVM&lt;/code&gt; 正常回收，导致内存泄露。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ANDROID组件或特殊集合对象的使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BraodcastReceiver，ContentObserver，FileObserver，Cursor，Callback&lt;/code&gt;等在 &lt;code&gt;Activity onDestroy&lt;/code&gt; 或者某类生命周期结束之后一定要 &lt;code&gt;unregister&lt;/code&gt; 或者 &lt;code&gt;close&lt;/code&gt; 掉，否则这个 &lt;code&gt;Activity&lt;/code&gt; 类会被 &lt;code&gt;system&lt;/code&gt; 强引用，不会被内存回收。&lt;/p&gt;

&lt;p&gt;不要直接对 &lt;code&gt;Activity&lt;/code&gt; 进行直接引用作为成员变量，如果不得不这么做，请用 &lt;code&gt;private WeakReference mActivity&lt;/code&gt; 来做，相同的，对于&lt;code&gt;Service&lt;/code&gt; 等其他有自己声明周期的对象来说，直接引用都需要谨慎考虑是否会存在内存泄露的可能。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HANDLER&lt;/p&gt;

&lt;p&gt;要知道，只要 &lt;code&gt;Handler&lt;/code&gt; 发送的 &lt;code&gt;Message&lt;/code&gt; 尚未被处理，则该 &lt;code&gt;Message&lt;/code&gt; 及发送它的 &lt;code&gt;Handler&lt;/code&gt; 对象将被线程 &lt;code&gt;MessageQueue&lt;/code&gt; 一直持有。由于 &lt;code&gt;Handler&lt;/code&gt; 属于 &lt;code&gt;TLS(Thread Local Storage)&lt;/code&gt; 变量, 生命周期和 &lt;code&gt;Activity&lt;/code&gt; 是不一致的。因此这种实现方式一般很难保证跟 &lt;code&gt;View&lt;/code&gt; 或者 &lt;code&gt;Activity&lt;/code&gt; 的生命周期保持一致，故很容易导致无法正确释放。如上所述，&lt;code&gt;Handler&lt;/code&gt; 的使用要尤为小心，否则将很容易导致内存泄露的发生。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;THREAD内存泄露&lt;/p&gt;

&lt;p&gt;线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。比如线程是 &lt;code&gt;Activity&lt;/code&gt; 的内部类，则线程对象中保存了 &lt;code&gt;Activity&lt;/code&gt; 的一个引用，当线程的 &lt;code&gt;run&lt;/code&gt; 函数耗时较长没有结束时，线程对象是不会被销毁的，因此它所引用的老的 &lt;code&gt;Activity&lt;/code&gt; 也不会被销毁，因此就出现了内存泄露的问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一些不良代码造成的内存压力&lt;/p&gt;

&lt;p&gt;有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。&lt;/p&gt;

&lt;p&gt;6.1 Bitmap 没调用 recycle()。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Bitmap&lt;/code&gt;对象在不使用时,我们应该先调用 &lt;code&gt;recycle()&lt;/code&gt; 释放内存，然后才它设置为 &lt;code&gt;null&lt;/code&gt;。因为加载 &lt;code&gt;Bitmap&lt;/code&gt; 对象的内存空间，一部分是 &lt;code&gt;java&lt;/code&gt; 的，一部分 &lt;code&gt;C&lt;/code&gt; 的（因为 &lt;code&gt;Bitmap&lt;/code&gt; 分配的底层是通过 &lt;code&gt;JNI&lt;/code&gt; 调用的 )。 而这个 &lt;code&gt;recycle()&lt;/code&gt; 就是针对 &lt;code&gt;C&lt;/code&gt; 部分的内存释放。&lt;/p&gt;

&lt;p&gt;6.2 构造 Adapter 时，没有使用缓存的 convertView。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;优秀实践&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对&lt;code&gt;activity&lt;/code&gt;等组件的引用应该控制在&lt;code&gt;activity&lt;/code&gt;的生命周期之内；如果不能就考虑使用&lt;code&gt;getApplicationContext&lt;/code&gt;或者&lt;code&gt;getApplication&lt;/code&gt;，以避免&lt;code&gt;activity&lt;/code&gt;被外部长生命周期的对象引用而泄露。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在代码复审的时候关注长生命周期对象：全局性的集合、单例模式的使用、类的&lt;code&gt;static&lt;/code&gt;变量等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括&lt;code&gt;context&lt;/code&gt;），即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt;的持有的引用对象最好使用弱引用，资源释放时也可以清空&lt;code&gt;Handler&lt;/code&gt;里面的消息。比如在&lt;code&gt;Activity onStop&lt;/code&gt;或者&lt;code&gt;onDestroy&lt;/code&gt;的时候，取消掉该&lt;code&gt;Handler&lt;/code&gt;对象的&lt;code&gt;Message&lt;/code&gt;和&lt;code&gt;Runnable&lt;/code&gt;，&lt;code&gt;removeCallbacks(Runnable r)&lt;/code&gt;或&lt;code&gt;removeMessages(int what)&lt;/code&gt;或&lt;code&gt;removeCallbacksAndMessages（null）&lt;/code&gt;等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程&lt;code&gt;Runnable&lt;/code&gt;执行耗时操作，注意在页面返回时及时取消或者把&lt;code&gt;Runnable&lt;/code&gt;写成静态类:
a) 如果线程类是内部类，改为静态内部类。
b) 线程内如果需要引用外部类对象如&lt;code&gt;context&lt;/code&gt;，需要使用弱引用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋空，如清空对图片等资源有直接引用或者间接引用的数组（使用&lt;code&gt;array.clear();array = null&lt;/code&gt;），最好遵循谁创建谁释放的原则。
&lt;hr&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;h4&gt;排查方法以及工具&lt;/h4&gt;&lt;br&gt;
&lt;h5&gt;MAT内存分析&lt;/h5&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;需要的软件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;；&lt;br&gt;
&lt;code&gt;Memory Analyzer&lt;/code&gt;，下载地址：&lt;a href=&#34;http://www.eclipse.org/mat/downloads.php&#34;&gt;http://www.eclipse.org/mat/downloads.php&lt;/a&gt;，下载完成后进行解压，双击&lt;code&gt;MemoryAnalyzer&lt;/code&gt;运行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何使用&lt;/p&gt;

&lt;p&gt;2.1 打开&lt;code&gt;Android Studio&lt;/code&gt;，&lt;code&gt;Run/Debug&lt;/code&gt;要进行分析的工程。&lt;/p&gt;

&lt;p&gt;2.2 启动&lt;code&gt;Android Studio&lt;/code&gt;工具栏上的&lt;code&gt;Android Device Monitor&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;2.3 在&lt;code&gt;Android Device Monitor&lt;/code&gt;中选中我们要进行分析的应用，然后点击&lt;code&gt;update heap&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;2.4 在应用内进行操作后，点击&lt;code&gt;DUMP HPROF file&lt;/code&gt;来保存&lt;code&gt;hprof&lt;/code&gt;文件。（建议保存到&lt;code&gt;sdk\platform-tools&lt;/code&gt;目录下，后面转换比较方便）&lt;/p&gt;

&lt;p&gt;2.5 进入到&lt;code&gt;sdk\platform-tools&lt;/code&gt;目录下，启动命令行，输入如下：&lt;code&gt;./hprof-conv inputName.hprof outputName.hprof&lt;/code&gt;。（由于都在一个目录下，输入输出文件可以不用指定位置）&lt;/p&gt;

&lt;p&gt;2.6 启动&lt;code&gt;Memory Analyzer&lt;/code&gt;，选择&lt;code&gt;File&amp;gt;open heap dump&lt;/code&gt;，打开刚才转换好的文件。&lt;/p&gt;

&lt;p&gt;2.7 点击&lt;code&gt;Leak Suspects&lt;/code&gt;会显示几个内存泄露疑点，在其中怀疑的地方，点击 &lt;code&gt;Details&lt;/code&gt; 就可以看到具体的内存使用情况。&lt;/p&gt;

&lt;p&gt;2.8 点击&lt;code&gt;Histogram&lt;/code&gt;，在出现的菜单中选中一项右键选择 &lt;code&gt;list objects&amp;gt;with incoming references&lt;/code&gt; 将列出该类的实例，如果想查看某个实例没被释放的原因，可以右健 &lt;code&gt;Path to GC Roots&amp;gt;exclude all phantom/weak/soft etc. reference&lt;/code&gt; ，这样可以去掉所有的虚/弱/软引用，以便我们快速查看某个对象的 &lt;code&gt;GC Root&lt;/code&gt;。（表头可以进行排序，在表的第一行可以输入正则表达式来匹配结果）&lt;/p&gt;

&lt;p&gt;2.9 有时候为查找内存泄漏，我们通常需要两个&lt;code&gt;Dump&lt;/code&gt;结果作对比，这时我们可以打开&lt;code&gt;Windows&amp;gt;Navigator History&lt;/code&gt;面板，将两个表的&lt;code&gt;Histogram&lt;/code&gt;结果都添加到&lt;code&gt;Compare Basket&lt;/code&gt;中去 ，然后点击面板右上角的红色叹号，得到对比结果，对比条件也是可设置的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个例子&lt;/p&gt;

&lt;p&gt;一个典型的分析内存泄漏的过程：&lt;/p&gt;

&lt;p&gt;3.1 使用&lt;code&gt;Heap&lt;/code&gt;查看当前堆大小为&lt;code&gt;23.00M&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;3.2 添加一个页后堆大小变为&lt;code&gt;23.40M&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;3.3 将添加的一个页删除，堆大小为&lt;code&gt;23.40M&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;3.4 多次操作，结果仍相似，说明添加/删除页存在内存泄漏 (也应注意排除其它因素的影响)；&lt;/p&gt;

&lt;p&gt;3.5 &lt;code&gt;Dump&lt;/code&gt;出操作前后的&lt;code&gt;hprof&lt;/code&gt;文件 &lt;code&gt;1.hprof,2.hprof&lt;/code&gt;，用&lt;code&gt;mat&lt;/code&gt;打开,并得到&lt;code&gt;histgram&lt;/code&gt;结果；&lt;/p&gt;

&lt;p&gt;3.6 使用&lt;code&gt;HomePage&lt;/code&gt;字段过滤&lt;code&gt;histgram&lt;/code&gt;结果，并列出该类的对象实例列表，看到两个表中的对象集合大小不同，操作后比操作前多出一个&lt;code&gt;HomePage&lt;/code&gt;，说明确实存在泄漏；&lt;/p&gt;

&lt;p&gt;3.7 将两个列表进行对比，找出多出的一个对象，用查找&lt;code&gt;GC Root&lt;/code&gt;的方法找出是谁串起了这条引用线路，定位结束。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;LeakCanary内存分析&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开始使用&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;build.gradle&lt;/code&gt; 中加入引用：&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dependencies {
    debugCompile &amp;lsquo;com.squareup.leakcanary:leakcanary-android:1.4-beta2&amp;rsquo;
    releaseCompile &amp;lsquo;com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2&amp;rsquo;
    testCompile &amp;lsquo;com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2&amp;rsquo;
}&lt;/code&gt;&lt;/pre&gt;
在&lt;code&gt;Application&lt;/code&gt;中：&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class VideoApplication extends Application {
    @Override
    public void onCreate() {
            super.onCreate();
            LeakCanary.install(this);
    }
}&lt;/code&gt;&lt;/pre&gt;
在 &lt;code&gt;debug build&lt;/code&gt; 中，如果检测到某个 &lt;code&gt;activity&lt;/code&gt; 有内存泄露，&lt;code&gt;LeakCanary&lt;/code&gt; 就是自动地显示一个通知。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何使用&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;RefWatcher&lt;/code&gt; 监控那些本该被回收的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RefWatcher refWatcher = {...};
// 监控
refWatcher.watch(schrodingerCat);
LeakCanary.install() 
//会返回一个预定义的 RefWatcher，同时也会启用一个 ActivityRefWatcher，用于自动监控调用 Activity.onDestroy() 之后泄露的 activity。
public class VideoApplication extends Application {

public static RefWatcher getRefWatcher(Context context) {
    VideoApplication application = (VideoApplication) context.getApplicationContext();
    return application.refWatcher;
}

private RefWatcher refWatcher;

@Override
public void onCreate() {
        super.onCreate();
        refWatcher = LeakCanary.install(this);
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;RefWatcher&lt;/code&gt; 监控 &lt;code&gt;Fragment&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onDestroy() {
    super.onDestroy();
    RefWatcher refWatcher = VideoApplication.getRefWatcher(getActivity());
    refWatcher.watch(this);
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工作机制&lt;/p&gt;

&lt;p&gt;3.1 &lt;code&gt;watch()&lt;/code&gt; 创建一个&lt;code&gt;KeyedWeakReference&lt;/code&gt; 到要被监控的对象。&lt;/p&gt;

&lt;p&gt;3.2 然后在后台线程检查引用是否被清除，如果没有，调用&lt;code&gt;GC&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3.3 如果引用还是未被清除，把 &lt;code&gt;heap&lt;/code&gt; 内存 &lt;code&gt;dump&lt;/code&gt; 到 &lt;code&gt;APP&lt;/code&gt; 对应的文件系统中的一个&lt;code&gt;.hprof&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;p&gt;3.4 在另外一个进程中的&lt;code&gt;HeapAnalyzerService&lt;/code&gt; 有一个 &lt;code&gt;HeapAnalyzer&lt;/code&gt; 使用&lt;code&gt;HAHA&lt;/code&gt; 解析这个文件。&lt;/p&gt;

&lt;p&gt;3.5 得益于唯一的 &lt;code&gt;reference key&lt;/code&gt;, &lt;code&gt;HeapAnalyzer&lt;/code&gt; 找到&lt;code&gt;KeyedWeakReference&lt;/code&gt;，定位内存泄露。&lt;/p&gt;

&lt;p&gt;3.6 &lt;code&gt;HeapAnalyzer&lt;/code&gt; 计算到 &lt;code&gt;GC roots&lt;/code&gt; 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。&lt;/p&gt;

&lt;p&gt;3.7 引用链传递到 &lt;code&gt;APP&lt;/code&gt; 进程中的&lt;code&gt;DisplayLeakService&lt;/code&gt;， 并以通知的形式展示出来。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何复制LEAK TRACE&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Logcat&lt;/code&gt; 中，你可以看到类似这样的 &lt;code&gt;leak trace&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;In com.example.leakcanary:1.0:1 com.example.leakcanary.MainActivity has leaked:
\* GC ROOT thread java.lang.Thread.&lt;Java Local&gt; (named &#39;AsyncTask #1&#39;)
\* references com.example.leakcanary.MainActivity$3.this$0 (anonymous class extends android.os.AsyncTask)
\* leaks com.example.leakcanary.MainActivity instance
\* Reference Key: e71f3bf5-d786-4145-8539-584afaecad1d
\* Device: Genymotion generic Google Nexus 6 - 5.1.0 - API 22 - 1440x2560 vbox86p
\* Android Version: 5.1 API: 22
\* Durations: watch=5086ms, gc=110ms, heap dump=435ms, analysis=2086ms&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LEAK TRACE之外&lt;/p&gt;

&lt;p&gt;有时，&lt;code&gt;leak trace&lt;/code&gt; 不够，你需要通过 &lt;code&gt;MAT&lt;/code&gt; 或者 &lt;code&gt;YourKit&lt;/code&gt; 深挖 &lt;code&gt;dump&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;通过以下方法，你能找到问题所在：&lt;/p&gt;

&lt;p&gt;5.1 查找所有的&lt;code&gt;squareup.leakcanary.KeyedWeakReference&lt;/code&gt; 实例。&lt;/p&gt;

&lt;p&gt;5.2 检查&lt;code&gt;key&lt;/code&gt; 字段。&lt;/p&gt;

&lt;p&gt;5.3 &lt;code&gt;Find the KeyedWeakReference that has a key field equal to the reference key reported by LeakCanary&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;5.4 找到 &lt;code&gt;key&lt;/code&gt; 和 和 &lt;code&gt;logcat&lt;/code&gt; 输出的 &lt;code&gt;key&lt;/code&gt; 值一样的&lt;code&gt;KeyedWeakReference&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;5.5 &lt;code&gt;referent&lt;/code&gt; 字段对应的就是泄露的对象。&lt;/p&gt;

&lt;p&gt;5.6 剩下的，就是动手修复了。最好是检查到 &lt;code&gt;GC root&lt;/code&gt; 的最短强引用路径开始。
&lt;hr&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;h4&gt;参考资料&lt;/h4&gt;&lt;br&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000003984512&#34;&gt;内存泄露从入门到精通三部曲之基础知识篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000004018386&#34;&gt;内存泄露从入门到精通三部曲之常见原因与用户实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000003991636&#34;&gt;内存泄露从入门到精通三部曲之排查方法篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.liaohuqiu.net/cn/posts/leak-canary-read-me/&#34;&gt;LeakCanary 中文使用说明&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>