<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gaoge&#39;s island</title>
    <link>https://gaogggg.github.io/tags/readingnotes/index.xml</link>
    <description>Recent content on Gaoge&#39;s island</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2016</copyright>
    <atom:link href="https://gaogggg.github.io/tags/readingnotes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Effective Java ReadingNotes 6</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes6/</link>
      <pubDate>Tue, 20 Dec 2016 18:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes6/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(6)&lt;/p&gt;

&lt;p&gt;Effective Java第7章 方法&lt;/p&gt;

&lt;h5&gt;38.检查参数的有效性&lt;/h5&gt;

&lt;p&gt;对于公有的方法，要用&lt;code&gt;Javadoc&lt;/code&gt;的&lt;code&gt;@throws&lt;/code&gt;标签在文档中说明违反参数值限制时会抛出的异常。&lt;/p&gt;

&lt;p&gt;非公有的方法通常应该使用断言&lt;code&gt;assertion&lt;/code&gt;来检查它们的参数。&lt;/p&gt;

&lt;p&gt;由于无效的参数值而导致计算过程抛出的异常，与文档中标明这个方法将抛出的异常并不相符，这种情况下，应该使用异常转译&lt;code&gt;exception translation&lt;/code&gt;技术，讲计算过程中抛出的异常转换为正确的异常。&lt;/p&gt;

&lt;h5&gt;39.必要时进行保护性拷贝&lt;/h5&gt;

&lt;p&gt;如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Period {  
    private final Date start;  
    private final Date end;  
    public Period(Date start,Date end) {  
        if(start.compareTo(end) &gt; 0){  
            throw new IllegalArgumentException(start + &#34; after &#34; + end);  
        }  
        this.start = start;  
        this.end = end;  
    }  
      
    public Date start(){  
        return start;  
    }  
      
    public Date end(){  
        return end;  
    }  
    //remainder omitted  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Period(Date start,Date end) {  
    this.start = new Date(start.getTime());  
    this.end = new Date(end.getTime());  
    if(this.start.compareTo(this.end) &gt; 0){  
        throw new IllegalArgumentException(this.start + &#34; after &#34; + this.end);  
    }

    public Date start(){  
        return new Date(start.getTime());  
    }   
    
    public Date end(){  
        return new Date(end.getTime());  
    }    
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;40.谨慎设计方法签名&lt;/h5&gt;

&lt;p&gt;谨慎地选择方法的名称。&lt;/p&gt;

&lt;p&gt;不要过于追求提供便利的方法。&lt;/p&gt;

&lt;p&gt;避免过长的参数列表。三种方法：1.把方法分解成多个方法，每个方法只需要这些参数的一个子集；2.创建辅助类，用来保存参数的分组；3.从对象构建到方法调用都采用&lt;code&gt;Builder&lt;/code&gt;模式。&lt;/p&gt;

&lt;p&gt;对于参数类型，要优先使用接口而不是类；对于&lt;code&gt;boolean&lt;/code&gt;参数，要优先使用两个元素的枚举类型。&lt;/p&gt;

&lt;h5&gt;41.慎用重载&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。对于涉及构造器的时候要避免同一组参数只需经过类型转换就可以被传递给不同的重载方法。如果不能就应该保证当传递同样的参数时，所有重载方法的行为必须一致。&lt;/p&gt;

&lt;h5&gt;42.慎用可变参数&lt;/h5&gt;

&lt;p&gt;在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。为了避免某些错误，可以让该方法带有两个参数，一个是指定类型的正常参数，另一个是这种类型的&lt;code&gt;varargs&lt;/code&gt;参数。&lt;/p&gt;

&lt;h5&gt;43.返回零长度的数组或者集合，而不是null&lt;/h5&gt;

&lt;p&gt;返回类型为数组或集合的方法没理由返回&lt;code&gt;null&lt;/code&gt;，而不是返回一个零长度的数组或者集合。&lt;/p&gt;

&lt;h5&gt;44.为所有导出的API元素编写文档注释&lt;/h5&gt;

&lt;p&gt;采用一致地风格来遵循标准的约定为&lt;code&gt;API&lt;/code&gt;编写文档注释。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 5</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes5/</link>
      <pubDate>Tue, 20 Dec 2016 13:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes5/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(5)&lt;/p&gt;

&lt;p&gt;Effective Java第6章 枚举和注解&lt;/p&gt;

&lt;h5&gt;30.用enum代替int常量&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public enum PayrollDay {  
    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(  
            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(  
            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);  
    private final PayType payType;  
  
    PayrollDay(PayType payType) {  
        this.payType = payType;  
    }  
      
    double pay(double hoursWorked, double payRate) {  
        return payType.pay(hoursWorked, payRate);  
    }  
  
    private enum PayType {  
        WEEKDAY {  
            double overtimePay(double hours, double payRate) {  
                return hours &lt;= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT)  
                        * payRate / 2;  
            }  
        },  
        WEEKEND {  
            double overtimePay(double hours, double payRate) {  
                return hours * payRate / 2;  
            }  
        };  
        private static final int HOURS_PER_SHIFT = 8;  
  
        abstract double overtimePay(double hours, double payRate);  
  
        double pay(double hoursWorked, double payRate) {  
            double basePay = hoursWorked * payRate;  
            return basePay + overtimePay(hoursWorked, payRate);  
        }  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;int&lt;/code&gt;常量相比，枚举要易读得多，也更加安全，功能更加强大。许多枚举都不需要显式的构造器或者成员，但许多其它枚举则受益于“每个常量与属性的关联”以及“提供行为受这个属性影响的方法”。只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个枚举常量同时享有相同的行为，则考虑策略枚举。&lt;/p&gt;

&lt;h5&gt;31.用实例域代替序数&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实力域中。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Ensemble{
  SOLO(1), DUET(2), TRIO(3), QUINTET(4), SEXTET(5), 
  SEPTET(7), OCTET(8), DOUBLE_QUARTET(8), NONET(9),
  DECTET(10), TRIPLE_QUARTRT(12);
  
  private final int numberOfMusicians;
  Ensemble(int size){
    this.numberOfMusicians = size;
  }
  public int numberofMusicians(){
    return numberOfMusicians;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enum&lt;/code&gt;规范中谈到&lt;code&gt;ordinal&lt;/code&gt;时这么写到：“大多数的程序员都不需要这个方法。它是设计成用于像&lt;code&gt;EnumSet&lt;/code&gt;和&lt;code&gt;EnumMap&lt;/code&gt;这种基于枚举的通用数据结构的。”除非你在编写的是这种数据结构，否则最好完全避免使用&lt;code&gt;ordinal&lt;/code&gt;方法。&lt;/p&gt;

&lt;h5&gt;32.用EnumSet代替位域&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;EnumSet&lt;/code&gt;类集位域的简洁和性能优势及第&lt;code&gt;30&lt;/code&gt;条中所述的枚举类型的所有的优点于一身。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Text{
    public enum TextStyle{BOLD, ITALIC, UNDERLINE, STRIKETHROUGH}
    public void applyStyles(Set&amp;lt;TextStyle&gt; styles){...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是将&lt;code&gt;EnumSet&lt;/code&gt;实例传递给&lt;code&gt;applyStyles&lt;/code&gt;方法的客户端代码。&lt;code&gt;EnumSet&lt;/code&gt;提供了丰富的静态工厂来创建集合，其中一个如这个代码所示：&lt;code&gt;text.applyStyles(EnumSet.of(TextStyle.BOLD,TextStyle.ITALIC));&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;33.用EnumMap代替序数索引&lt;/h5&gt;

&lt;p&gt;序数索引是指依赖于枚举成员在枚举中的序数来进行数组索引，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Plant{
    public enum Type { Fruit, Vegetables, Tree}
    private final String name;
    private final Type type;

    Plant(String name, Type type){
        this.name = name;
        this.type = type;
    }
}

Set&amp;lt;Plant&gt;[] plants = (Set&lt;Plant&gt;[]) new Set[Plant.Type.valuse().lenght]; 
//根据植物的类型，分别把所有的植物放入三个set中
for(int i = 0; i &lt; plant.lenght; i++){
   plant[i] = new HashSet&lt;Plant&gt;();
}

for(Plant p : garden){  //garden里放了所有的植物
    plant[p.type.ordinal()].add(p)  //反面教材：利用了枚举的序数来得到想要的数组索引，用户在其他地方可以不使用ordinal函数，而直接使用int值来访问，就可能出错
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该使用&lt;code&gt;EnumMap&lt;/code&gt;来实现，&lt;code&gt;EnumMap&lt;/code&gt;内部是采用数组实现的，具有&lt;code&gt;Map&lt;/code&gt;的丰富功能和类型安全以及数组的效率：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;Plant.Type, Set&lt;Plant&gt;&gt; plants = new EnumMap&amp;lt;Plant.Type, Set&lt;Plant&gt;&gt;(Plant.Type.class);  //构造函数需要 键 类型的Class对象
//根据植物的类型，分别把所有的植物放入三个set中
for(Plant.Type type : Plant.Type.valuse()){
   plant.put(type, new HashSet&lt;Plant&gt;);
}

for(Plant p : garden){  //garden里放了所有的植物
    plant.get(p.type).add(p)  //用户必须使用正确的键值来访问，即Type类型
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要多维关系时，可以使用&lt;code&gt;EnumMap&amp;lt;..., EnumMap&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;34.用接口模拟可伸缩的枚举&lt;/h5&gt;

&lt;p&gt;虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。这样允许客户端编写自己的枚举来实现接口。如果API是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Operation{
    double apply(double x,double y);
}

public enum BasicOperation implements Operation{

    PLUS(&#34;^&#34;){
        public double apply(double x,double y){ return Math.pow(x,y);}
    },
    MINUS(&#34;%&#34;){
        public double apply(double x,double y){ return x % y;}
    };

    private final String symbool;
    BasicOperation(String symbool){ this.symbool = symbool}

    @Override
    public String toString() {
        return symbool;
    }

    @Override
    public double apply(double x, double y) {
        return 0;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过以下两种方法传递完整的扩展枚举类型，并使用它的元素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;T extends Enum&amp;lt;T&amp;gt; &amp;amp; Operation&amp;gt; Class&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Collection&amp;lt;? Extends Operation&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;35.注解优先于命名模式&lt;/h5&gt;

&lt;p&gt;命名模式的缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;无法处理命名失误的情况；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无法确保它们只用于响应的程序元素上；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;他们没有提供将参数值与程序元素关联起来的好方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;36.坚持使用Override注解&lt;/h5&gt;

&lt;p&gt;在每个方法声明中使用&lt;code&gt;Override&lt;/code&gt;注解来覆盖超类声明。&lt;/p&gt;

&lt;h5&gt;37.用标记接口定义类型&lt;/h5&gt;

&lt;p&gt;标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型；标记接口可以被更加精确地进行锁定。&lt;/p&gt;

&lt;p&gt;标记注解胜过标记接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给已被使用的注解类型添加更多的信息，它的另一个优点在于它们使更大的注解机制的一部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果想要定义类型，一定要使用接口。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 4</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes4/</link>
      <pubDate>Fri, 16 Dec 2016 18:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes4/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(4)&lt;/p&gt;

&lt;p&gt;Effective Java第5章 泛型&lt;/p&gt;

&lt;h5&gt;23.请不要在新代码中使用原生态类型&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Set&amp;lt;Object&amp;gt;&lt;/code&gt;是个参数化类型，表示可以包含任何对象类型的一个集合；&lt;code&gt;Set&amp;lt;?&amp;gt;&lt;/code&gt;则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；&lt;code&gt;Set&lt;/code&gt;则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。&lt;/p&gt;

&lt;h5&gt;24.消除非受检警告&lt;/h5&gt;

&lt;p&gt;本处主要介绍比较难以消除的警告的示例。&lt;/p&gt;

&lt;p&gt;如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个&lt;code&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/code&gt;注解来禁止这条警告。&lt;strong&gt;应该始终在尽可能小的范围中使用&lt;code&gt;SuppressWarnings&lt;/code&gt;注解，并且每当使用该注解时都要添加一条注释，说明为什么这么做是安全的。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;25.列表优先于数组&lt;/h5&gt;

&lt;p&gt;数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。一般来说，数组和泛型不能很好地混合使用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表代替数组。&lt;/p&gt;

&lt;h5&gt;26.优先考虑泛型&lt;/h5&gt;

&lt;p&gt;看如下一个简单堆栈的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Stack {
    pprivate Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITAL_CAPACITY = 16;
    
    public Stack() {
        elements = new Object[DEFAULT_INITAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if(size == 0) {
            throw new EmptyStackException();
        }
        Object result = elements[--size];
        elements[size] = null;
        return result;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }

    private void ensureCapacity() {
        if(elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将该类泛型化可以提高类型的安全性，方便客户端使用(无需显式强制转换类型)&lt;/p&gt;

&lt;p&gt;用类型参数替换所有的&lt;code&gt;Object&lt;/code&gt;类型：&lt;code&gt;private E[] elements;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于不能创建不可具体化类型的数组，所以会报错&lt;code&gt;generic array creation new E[DEFAULT_INITIAL_CAPACITY]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们有两种解决办法：&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;1.创建一个&lt;code&gt;Object&lt;/code&gt;数组，并将它转换成泛型数组类型：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];&lt;/code&gt;
错误变成一条警告，因为可以保证类型安全，所以可以用&lt;code&gt;SupressWarning&lt;/code&gt;注释忽略掉该警告。&lt;/p&gt;

&lt;p&gt;2.将&lt;code&gt;elements&lt;/code&gt;域的类型从&lt;code&gt;E[]&lt;/code&gt;改为&lt;code&gt;Object[]&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object[] elements;

E result = (E) elements[--size];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;产生一条警告，因为可以保证类型安全，所以可以用&lt;code&gt;SupressWarning&lt;/code&gt;注释忽略掉该警告。&lt;/p&gt;

&lt;p&gt;这两种方法，一般来说禁止数组类型的未受检转换比禁止标题类型更危险，所以建议使用第二种方法。但是在比这个例子更实际的泛型中，或许代码中会有多个地方需要从数组中读取元素，因此第一种方法比第二种方法开销更小一些，这也是第一种方法更常用的原因。这个例子看起来违反了&lt;code&gt;25&lt;/code&gt;条(它告诉我们对于泛型列表要优于数组)，实际上因为&lt;code&gt;Java&lt;/code&gt;并不是生来就支持列表，所以有些泛型如&lt;code&gt;ArrayList&lt;/code&gt;必须使用数组来实现，有的时候为了提升性能，也会考虑用数组来实现，比如&lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;总之，使用泛型比使用需要在客户端代码中进行转化的类型来的更安全。也更容易，在设计新类的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成是泛型的。&lt;/p&gt;

&lt;h5&gt;27.优先考虑泛型方法&lt;/h5&gt;

&lt;p&gt;考虑如下的方法，它的作用是返回两个集合的联合：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Set union(Set s1, Set s2) {  
    Set result = new HashSet(s1);  
    result.addAll(s2);  
    return result;  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译这段代码会产生警告，为了修正这些警告(在新代码中不应该直接使用原始类型，当前是为了举例子)要将方法声名修改为声明一个类型参数，表示这三个元素类型(两个参数及一个返回值)，并在方法中使用类型参数。声名类型参数的类型参数列表，处在方法的修饰符及其返回类型之间，修改后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;E&gt; Set&amp;lt;E&gt; union(Set&amp;lt;E&gt; s1, Set&amp;lt;E&gt; s2) {  
    Set&amp;lt;E&gt; result = new HashSet&amp;lt;E&gt;(s1);  
    result.addAll(s2);  
    return result;  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前这个版本的&lt;code&gt;union&lt;/code&gt;方法即为一般的泛型方法，但是它有一个限制，要求三个集合的类型(两个输入参数及一个返回值)必须全部相同。利用有限制的通配符类型可以使这个方法变得更回灵活。&lt;/p&gt;

&lt;p&gt;泛型方法的一个显著特征是，无需明确指定类型参数的值，不像调用泛型构造器的时候是必须要指定类型参数的，在为泛型方法的类型会存在一个类型推导的过程。编译器通过检查方法参数的类型来计算类型的值。在调用 泛型构造器的时候，要明确传递类型参数的值可能有点麻烦。类型参数出现在了变量的声明的左右两边，显得冗余：&lt;code&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于这情况，可以遵照第&lt;code&gt;1&lt;/code&gt;条，提供一个静态工厂方法来简化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;K, V&gt; HashMap&amp;lt;K, V&gt; newHashMap() {  
    return new HashMap&amp;lt;K, V&gt;();  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用上面的静态工厂方法，我们可以把变量声明右侧的参数类型省略掉，当参数类型多而复杂时尤其有效。&lt;/p&gt;

&lt;p&gt;有时会需要创建不可变但是又适合于许多不同类型的对象，由于泛型是通过擦除来实现的，可以给所有的必要的类型参数使用同一个单个对象，但是需要一个静态的工厂方法来给每个必要的类型参数分发对象。这种模式叫做&amp;rdquo;泛型单例工厂&amp;rdquo;，这种模式最常用于函数的对象。假设有一个接口，描述了一个方法，该方法接受和返回某个类型&lt;code&gt;T&lt;/code&gt;的值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UnaryFunction&amp;lt;T&gt; {  
    T apply(T arg);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在假设要提供一个恒等函数，如果 在每次需要的时候都重新创建一个这样会很浪费，因为它是无状态的。如果泛型被具体化，那个每个类型都必须持有相应类型的恒等函数，但是在运行时擦除类型信息后，它们并没有什么区别，所以在这种情况下，只需要一个泛型单例就够了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static UnaryFunction
 INDENTITY_FUNCTION = new UnaryFunction {
    public Object apply(Object arg) { return arg; }  
}; 

@SuppressWarnings(&#34;unchecked&#34;)
public static  UnaryFunction indentityFunction() {
    return (UnaryFunction)INDENTITY_FUNCTION;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归类型限制最普遍的用途与&lt;code&gt;Comparable&lt;/code&gt;接口有关，它定义类型的自然顺序。许多方法都带有一个实现&lt;code&gt;Comparable&lt;/code&gt;接口的元素列表，为了对列表进行排序，并在其中进行搜索，计算出它的最小值或者最大值等等。要完成这其中的任何一项工作要求列表中的每个元素都能够与列表中的其他元素相比较，一个示例：&lt;code&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list) {  }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的声名要求&lt;code&gt;T&lt;/code&gt;是可以与自身同类型对象相比较的类型，&lt;code&gt;extends&lt;/code&gt;可以解释为&amp;rdquo;实现某功能&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;总之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来的更加安全，也更加容易。就像类型一样，你应该确保新的方法可以不用转换就能使用，这通常意味着要将它们泛型化。并且就像类型一样，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会破坏现有的客户端。&lt;/p&gt;

&lt;h5&gt;28.利用有限制通配符来提升API的灵活性&lt;/h5&gt;

&lt;p&gt;为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。&lt;code&gt;PESC&lt;/code&gt;表示&lt;code&gt;producter-extends&lt;/code&gt;, &lt;code&gt;consumer-super&lt;/code&gt;。如果参数化类型表示一个&lt;code&gt;T&lt;/code&gt;生产者，就使用&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;；如果它表示一个&lt;code&gt;T&lt;/code&gt;消费者，就使用&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果类型参数只在方法声明中出现一次，就可以用通配符取代它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void swap(List&amp;lt;?&gt; list, int i, int j) {  
    swapHelper(list, i, j);  
}  
  
private static &amp;lt;E&gt; void swapHelper(List&amp;lt;E&gt; list, int i, int j) {  
    list.set(i, list.set(j, list.get(i)));  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;所有的&lt;code&gt;comparable&lt;/code&gt;和&lt;code&gt;comparator&lt;/code&gt;都是消费者。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;29.优先考虑类型安全的异构容器&lt;/h5&gt;

&lt;p&gt;有时会需要未限定固定数目的类型参数的容器，此时，可以将容器的键进行参数化而不是将容器参数化。然后将参数化的键交给容器来插入或者获得值。用泛型系统来确保值的类型和它的键相符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ManyTypeClass
{
    //一个存放数据的容器,由于键值类型是不确定的，那么值类型就只能是object类型
    private Map&amp;lt;Class&amp;lt;?&gt;, Object&gt; data = new HashMap&amp;lt;Class&amp;lt;?&gt;, Object&gt;();
    
    public &amp;lt;T&gt; void putData(Class&amp;lt;T&gt; type, T instance)
    {
        //吧数据放入进去
        if(type != null)
        {
            //这里需要进行一下类型转换，通过Class的cast方法，因为泛型是基于擦除的，如果不进行验证的话，那么插入的数据到底是不是真的type类型就无法确定的了
            data.put(type, type.cast(instance));
        }
    }
    
    public &amp;lt;T&gt; T getDate(Class&amp;lt;T&gt; type)
    {
        //取出数据,由于数据存放进去是object类型的，那么取出来的时候就需要进行一次类型转换
        return type.cast(data.get(type));
    }
    
    public static void main(String[] args)
    {
        ManyTypeClass mtc = new ManyTypeClass();
        mtc.putData(String.class, &#34;cutter_point&#34;);
        mtc.putData(Integer.class, 0xcab145de);
        mtc.putData(Class.class, ManyTypeClass.class);
        mtc.putData(ManyTypeClass.class, mtc);
        
        String dataString = mtc.getDate(String.class);
        int dataInteger = mtc.getDate(Integer.class);
        Class&amp;lt;?&gt; dataClass = mtc.getDate(Class.class);
        ManyTypeClass mtc1 = mtc.getDate(ManyTypeClass.class);
        
        System.out.printf(&#34;%s %x %s %s%n&#34;, dataString,
                dataInteger, dataClass.getName(), mtc1.getDate(String.class));
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能存储&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;。因为在运行时他们的类型会被擦除，所以&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;与&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;实际上是共用一个Class。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 3</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes3/</link>
      <pubDate>Fri, 16 Dec 2016 14:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes3/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(3)&lt;/p&gt;

&lt;p&gt;Effective Java第4章 类和接口&lt;/p&gt;

&lt;h5&gt;13.使类和成员的可访问性最小化&lt;/h5&gt;

&lt;p&gt;访问控制机制决定了类、接口和成员的可访问性。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符共同决定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尽可能地使每个类或者成员不被外界访问。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;私有的&lt;code&gt;private&lt;/code&gt;——只有在声明该成员的顶层类内部才可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包级私有的&lt;code&gt;package-private/default&lt;/code&gt;——声明该成员的包内部的任何类都可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;受保护的&lt;code&gt;protected&lt;/code&gt;——声明该成员的类的子类可以访问这个成员（有一些限制），并且，声明该成员的包内部的任何类也可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;公有的&lt;code&gt;public&lt;/code&gt;——在任何地方都可以访问该成员。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现了Serializable接口的类的私有域可能会被“泄漏”。&lt;/p&gt;

&lt;p&gt;子类中的访问级别不允许低于超类中的访问级别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;除了公有静态final域的特殊情形之外，公有类都不应该包含公有域。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;14.在公有类中使用访问方法而非公有域&lt;/h5&gt;

&lt;p&gt;如果类可以在它所在的包的外部进行访问，就提供访问方法。公有类永远都不应该暴露可变的域。但是，有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变还是不可变的。&lt;/p&gt;

&lt;h5&gt;15.使可变性最小化&lt;/h5&gt;

&lt;p&gt;不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。&lt;/p&gt;

&lt;p&gt;为了使类成为不可变，要遵循下面五条规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要提供任何会修改对象状态的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保证类不会被扩展。一般使类成为&lt;code&gt;final&lt;/code&gt;，但后面还会讨论其他做法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使所有的域都是&lt;code&gt;final&lt;/code&gt;的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使所有的域都成为私有的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确保对于任何可变组件的互斥访问。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不可变对象本质上是线程安全的，它们不要求同步；不仅可以共享不可变对象，甚至也可以共享它们的内部信息；不可以对象为其他对象提供了大量的构件。&lt;strong&gt;不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让不可变的类变成&lt;code&gt;final&lt;/code&gt;的另一种方法就是，让类的所有构造器都变成私有的或者包级私有的，并添加公有的静态工厂来代替公有的构造器。&lt;/p&gt;

&lt;h5&gt;*16.复合优先于继承&lt;/h5&gt;

&lt;p&gt;继承打破了封装性，子类依赖于其超类中特定功能的实现细节。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。&lt;/p&gt;

&lt;p&gt;为了避免继承导致的脆弱性，我们可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {
    private final Set&lt;E&gt; s;

    public ForwardingSet(Set&lt;E&gt; s) {
        this.s = s;
    }

    public void clear() {
        s.clear();
    }

    public boolean contains(Object o) {
        return s.contains(o);
    }

    public boolean isEmpty() {
        return s.isEmpty();
    }

    public int size() {
        return s.size();
    }

    public Iterator&lt;E&gt; iterator() {
        return s.iterator();
    }

    public boolean add(E e) {
        return s.add(e);
    }

    public boolean remove(Object o) {
        return s.remove(o);
    }

    public boolean containsAll(Collection&lt;?&gt; c) {
        return s.containsAll(c);
    }

    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return s.addAll(c);
    }

    public boolean removeAll(Collection&lt;?&gt; c) {
        return s.removeAll(c);
    }

    public boolean retainAll(Collection&lt;?&gt; c) {
        return s.retainAll(c);
    }

    public Object[] toArray() {
        return s.toArray();
    }

    public &lt;T&gt; T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}

public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {
    private int addCount = 0;

    public InstrumentedSet(Set&lt;E&gt; s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;17.要么为继承而设计，并提供文档说明，要么就禁止继承&lt;/h5&gt;

&lt;p&gt;为继承而设计的类必须有文档说明它可覆盖&lt;code&gt;overridable&lt;/code&gt;的方法的自用性，且必须通过某种形式提供适当的钩子&lt;code&gt;hook&lt;/code&gt;，以便能够进入到它的内部工作流程中，这种形式可以使精心选择的受保护&lt;code&gt;protected&lt;/code&gt;的方法，也可以是受保护的域，后者比较少见。该类的唯一的测试方法就是编写子类。&lt;/p&gt;

&lt;p&gt;为了允许继承，类还必须遵守其他一些约束。&lt;strong&gt;构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;18.接口优于抽象类&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现有的类可以很容易被更新，以实现新的接口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口是定义&lt;code&gt;mixin(混合类型)&lt;/code&gt;的理想选择。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口允许我们构造非层次结构的类型框架。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抽象类的演变比接口的演变要容易得多。&lt;strong&gt;接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;19.接口只用于定义类型&lt;/h5&gt;

&lt;p&gt;接口应该只被用来定义类型，不应该被用来导出常量，导出常量可以使用枚举类型和不可实例化的工具类。&lt;/p&gt;

&lt;h5&gt;20.类层次优于标签类&lt;/h5&gt;

&lt;p&gt;标签类过于冗长、容易出错，并且效率低下。标签类很少有适用的时候，当你想要编写一个包含显式标签域的类时，应该考虑一下这个标签是否可以被取消，这个类是否可以使用类层次来代替。&lt;/p&gt;

&lt;p&gt;以下为一个标签类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Figure {  
    enum Shape { RECTANGLE, CIRCLE };  
  
    // Tag field - the shape of this figure  
    final Shape shape;  
  
    // These fields are used only if shape is RECTANGLE  
    double length;  
    double width;  
  
    // This field is used only if shape is CIRCLE  
    double radius;  
  
    // Constructor for circle  
    Figure(double radius) {  
        shape = Shape.CIRCLE;  
        this.radius = radius;  
    }  
  
    // Constructor for rectangle  
    Figure(double length, double width) {  
        shape = Shape.RECTANGLE;  
        this.length = length;  
        this.width = width;  
    }  
  
    double area() {  
        switch(shape) {  
          case RECTANGLE:  
            return length * width;  
          case CIRCLE:  
            return Math.PI * (radius * radius);  
          default:  
            throw new AssertionError();  
        }  
    }  
}&lt;/code&gt;&lt;/pre&gt;  

&lt;p&gt;修改后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class Figure {  
    abstract double area();  
}  
class Circle extends Figure {  
    final double radius;  
  
    Circle(double radius) { this.radius = radius; }  
  
    double area() { return Math.PI * (radius * radius); }  
}  
class Rectangle extends Figure {  
    final double length;  
    final double width;  
  
    Rectangle(double length, double width) {  
        this.length = length;  
        this.width  = width;  
    }  
    double area() { return length * width; }  
}  
class Square extends Rectangle {  
    Square(double side) {  
        super(side, side);  
    }  
}&lt;/code&gt;&lt;/pre&gt;  

&lt;h5&gt;21.用函数对象表示策略&lt;/h5&gt;

&lt;p&gt;函数指针的主要用途就是实现策略模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体的策略只被使用一次时，通常使用匿名内部类来声明和实例化这个具体策略类。当一个具体策略被设计用来重复使用的时候，它的类通常要被实现为私有的静态成员，并通过公有的静态final域被导出，其类型为该策略接口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Arrays.sort(StringArray,new Comparator&lt;String&gt;(){
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Host {
    private static class StrLenCmp implements Comparator&lt;String&gt;,Serializable{
 
        @Override
        public int compare(String s1, String s2) {
            return s1.length() - s2.length();
        }
    }
     
    public static final Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = new StrLenCmp();
     
    public static void main(String[] args) {
        String s1 = &#34;&#34;;
        String s2 = &#34;&#34;;
        int result = Host.STRING_LENGTH_COMPARATOR.compare(s1, s2);
        System.out.println(result);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;22.优先考虑静态成员类&lt;/h5&gt;

&lt;p&gt;嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。如果嵌套类将来可能会用于其他的某个环境中，他就应该是顶层类。嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类。除了第一种之外，其他三种都称为内部类。&lt;/p&gt;

&lt;p&gt;从语法上讲，静态成员类和非静态成员类之间的唯一区别是，静态成员类的声明中包含修饰符&lt;code&gt;static&lt;/code&gt;。尽管他们的语法非常相似，但是两种嵌套类有很大的不同。非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修改过的&lt;code&gt;this&lt;/code&gt;构造获得外围实例的引用。如果嵌套类的实例可以在他外围类的实力之外独立存在，这个嵌套类就必须是静态成员类，在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。&lt;/p&gt;

&lt;p&gt;当非静态成员类的实例被创建的时候，他和外围之间的关联关系也随之被创立起来；而且，这种关联关系以后不能被修改。通常情况下，当在外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关系被自动建立起来。
使用表达式enclosingInstance.new MemberClass(args)来手工建立这种关联关系也是有可能的，但是很少使用。正如你所预料的那样，这种关联关系需要消耗费静态成员类的实例空间，并且构造的时间开销。&lt;/p&gt;

&lt;p&gt;如果声明成员类不要求访问外围实例，就要始终把&lt;code&gt;static&lt;/code&gt;修饰符放在他的声明中。&lt;/p&gt;

&lt;p&gt;匿名类的三种常见用法：1.动态的创建函数对象，如&lt;code&gt;sort&lt;/code&gt;方法的调用利用了匿名的&lt;code&gt;Comparator&lt;/code&gt;实例；2.创建过程对象，如&lt;code&gt;Runnable&lt;/code&gt;、&lt;code&gt;Thread&lt;/code&gt;或者&lt;code&gt;TimerTask&lt;/code&gt;实例；3.在静态工厂方法的内部使用。&lt;/p&gt;

&lt;p&gt;如果一个嵌套类需要在单个方法之外仍然是可见的，或者他太长了，不适合方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则就做成静态的。假设这个嵌套类属于一个方法的内部，如果你需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就把他做成匿名类；否则，就做成局部类。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 2</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</link>
      <pubDate>Thu, 15 Dec 2016 19:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(2)&lt;/p&gt;

&lt;p&gt;Effective Java第3章 对于所有对象都通用的方法&lt;/p&gt;

&lt;h5&gt;8.覆盖equals时请遵守通用约定&lt;/h5&gt;

&lt;p&gt;覆盖&lt;code&gt;Object.equals&lt;/code&gt;的时机：类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖&lt;code&gt;equals&lt;/code&gt;以实现期望的行为。这通常属于“值类”的情形，有一种“值类”不需要覆盖&lt;code&gt;equals&lt;/code&gt;方法，即用实例受控确保“每个值至多只存在一个对象”的类，比如枚举类型。&lt;/p&gt;

&lt;p&gt;在覆盖&lt;code&gt;equals&lt;/code&gt;方法的时候，你必须要遵守它的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自反性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x.equals(x)&lt;/code&gt;必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对称性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;，当且仅当&lt;code&gt;y.equals(x)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;时，&lt;code&gt;x.equals(y)&lt;/code&gt;必须返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传递性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x、y和z&lt;/code&gt;，如果&lt;code&gt;x.equals(y)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;，并且&lt;code&gt;y.equals(z)&lt;/code&gt;也返回&lt;code&gt;true&lt;/code&gt;，那么&lt;code&gt;x.equals(z)&lt;/code&gt;也必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一致性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x和y&lt;/code&gt;，只要&lt;code&gt;equals&lt;/code&gt;的比较操作在对象中所用的信息没有被修改，多次调用&lt;code&gt;x.equals(y)&lt;/code&gt;就会一致地返回&lt;code&gt;true&lt;/code&gt;，或者一致地返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于任何非null的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x,equals(null)&lt;/code&gt;必须返回false。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现高质量&lt;code&gt;equals&lt;/code&gt;方法的诀窍：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;==&lt;/code&gt;操作符检查“参数是否为这个对象的引用”。如果是，则返回&lt;code&gt;true&lt;/code&gt;。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;instanceof&lt;/code&gt;操作符检查“参数是否为正确的类型”。如果不是，则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把参数转换成正确的类型。因为转换前进行过&lt;code&gt;instanceof&lt;/code&gt;测试，所以确保会成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于既不是&lt;code&gt;float&lt;/code&gt;也不是&lt;code&gt;double&lt;/code&gt;类型的基本类型域，可以使用&lt;code&gt;==&lt;/code&gt;操作符进行比较，对于对象引用域，可以递归地调用&lt;code&gt;equals&lt;/code&gt;方法；对于&lt;code&gt;float&lt;/code&gt;域，可以使用&lt;code&gt;Float.compare&lt;/code&gt;方法；对于&lt;code&gt;double&lt;/code&gt;域，则使用&lt;code&gt;Double.compare&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;9.覆盖equals时总要覆盖hashCode&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Object.hashCode&lt;/code&gt;的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在应用程序的执行期间，只要对象的&lt;code&gt;equals&lt;/code&gt;方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次,&lt;code&gt;hashCode&lt;/code&gt;方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法都必须产生同样的整数结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是不相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;10.始终要覆盖toString&lt;/h5&gt;

&lt;p&gt;提供好的&lt;code&gt;toString&lt;/code&gt;实现可以使类用起来更加舒适，在实际应用中，&lt;code&gt;toString&lt;/code&gt;方法应该返回对象中包含的所有值得关注的信息。&lt;/p&gt;

&lt;h5&gt;11.谨慎地覆盖clone&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Clone&lt;/code&gt;方法的通用约定：
对于任何对象&lt;code&gt;x&lt;/code&gt;，表达式&lt;code&gt;x.clone() != x&lt;/code&gt; 将会是&lt;code&gt;true&lt;/code&gt;，并且，表达式&lt;code&gt;x.clone().getClass() == x.getClass()&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但这些都不是绝对的要求。虽然通常情况下，表达式&lt;code&gt;x.clone().equals(x)&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但是，这也不是一个绝对的要求。拷贝对象往往会导致创建它的类的一个新实例，但它同时也会要求拷贝内部的数据结构。这个过程中没有调用构造器。&lt;/p&gt;

&lt;p&gt;所有实现了&lt;code&gt;Cloneable&lt;/code&gt;接口的类都应该用一个公有的方法覆盖&lt;code&gt;clone&lt;/code&gt;。此公有方法首先调用&lt;code&gt;super.clone&lt;/code&gt;，然后修正任何需要修正的域。一般情况下，这意味着要拷贝任何包含内部“深层结构”的可变对象，并用指向新对象的引用代替原来指向这些对象的引用。虽然，这些内部拷贝操作往往可以通过递归地调用&lt;code&gt;clone&lt;/code&gt;来完成，但这通常并不是最佳方法。如果该类只包含基本类型的域，或者指向不可变对象的引用，那么多半的情况是没有域需要修正。这条规则也有例外，譬如，代表序列号或其他唯一ID值得域，或者代表对象的创建时间的域，不管这些域是基本类型还是不可变的，它们也都需要被修正。&lt;/p&gt;

&lt;p&gt;另一个实现对象拷贝的好办法是提供一个拷贝构造器或拷贝工厂。拷贝构造器只是一个构造器，它唯一的参数类型是包含该构造器的类。如&lt;code&gt;public Go(Go go);&lt;/code&gt;，拷贝工厂是类似于拷贝构造器的静态工厂&lt;code&gt;public static Go newInstance(Go go);&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;12.考虑实现Comparable接口&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;compareTo&lt;/code&gt;方法的通用约定：&lt;/p&gt;

&lt;p&gt;讲这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。&lt;/p&gt;

&lt;p&gt;在下面的说明中，符号&lt;code&gt;sgn&lt;/code&gt;表示数学中的&lt;code&gt;signum&lt;/code&gt;函数，它根据表达式的值为负值、零和正值，分别返回-1、0或1。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实现者必须确保所有的&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(y)) == -sgn(y.compareTo(x))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现者还必须确保这个比较关系是可传递的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，实现者必须确保&lt;code&gt;x.compareTo(y) == 0&lt;/code&gt;暗示着所有的&lt;code&gt;z&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强烈建议&lt;code&gt;(x.compareTo(y) == 0) == (x.equals(y))&lt;/code&gt;，但这并非绝对必要。一般说来，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有内在的排序功能，但是与equals不一致。”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 1</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</link>
      <pubDate>Thu, 15 Dec 2016 16:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(1)&lt;/p&gt;

&lt;p&gt;Effective Java第2章 创建和销毁对象&lt;/p&gt;

&lt;h5&gt;1.考虑用静态工厂方法代替构造器&lt;/h5&gt;

&lt;p&gt;静态工厂方法相较于构造器有四大优势：（1）它们有名称；（2）不必在每次调用它们的时候都创建一个新对象；（3）它们可以返回原返回类型的任何子类型的对象；（4）在创建参数化类型实例时，它们使代码变得更加简洁。两大缺点：（1）类如果不含公有的或受保护的构造器，就不能被子类化；（2）它们与其他的静态方法实际上并没有任何区别。&lt;/p&gt;

&lt;h5&gt;2.遇到多个构造器参数时要考虑用构建器&lt;/h5&gt;

&lt;p&gt;一个很直观的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;

    public static class Builder {
        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;

        public Builder(int servingSize, int servings){
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val){
            calories = val;
            return this;
        }

        public Builder fat(int val){
            fat = val;
            return this;
        }

        public NutritionFacts build(){
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder){
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要创建一个实例时只需根据自己的需要添加参数&lt;code&gt;NutritionFacts cocaCola = new Builder(240,8).calories(100).build();&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;3.用私有构造器或者枚举类型强化Singleton属性&lt;/h5&gt;

&lt;p&gt;除了非常常见的两种单例实现方法外，在Java 1.5之后我们有了一个更好的选择，使用单元素枚举类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum SingleTon {
    INSTANCE;
    public void orz() {
        //blablabla
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后如此调用&lt;code&gt;SingleTon s1 = SingleTon.INSTANCE;s1.orz();&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;4.通过私有构造器强化不可实例化的能力&lt;/h5&gt;

&lt;p&gt;对于一些只包含静态方法和静态域的工具类，我们不希望它被实例化，可以通过以下方式进行强化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UtilityClass{
    //Suppress default constructor for moninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;5.避免创建不必要的对象&lt;/h5&gt;

&lt;p&gt;一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。&lt;/p&gt;

&lt;p&gt;对于可重用的对象可以通过使用一个静态的初始化器&lt;code&gt;static{}&lt;/code&gt;来创建以避免重复创建，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。维护自己的对象池来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的，其中一个典型示例为数据库连接池。&lt;/p&gt;

&lt;h5&gt;6.消除过期的对象引用&lt;/h5&gt;

&lt;p&gt;要警惕内存泄漏问题，及时清除过期引用，使用合适的数据结构保存缓存、监听器以及其他回调，例如&lt;code&gt;WeakReference&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;7.避免使用终结方法&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;finalizer&lt;/code&gt;通常是不可预测的，也是很危险的，一般情况下是不必要的，并且该方法会导致严重的性能损失。如果类的对象中封装的资源确实需要终止，我们应该提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。终结方法有两种合法用途：1、充当&amp;rdquo;安全网&amp;rdquo;；2、终止非关键的本地资源。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>