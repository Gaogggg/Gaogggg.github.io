<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gaoge&#39;s island</title>
    <link>https://Gaogggg.github.io/tags/readingnotes/index.xml</link>
    <description>Recent content on Gaoge&#39;s island</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2016</copyright>
    <atom:link href="https://Gaogggg.github.io/tags/readingnotes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Effective Java ReadingNotes 1</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</link>
      <pubDate>Thu, 15 Dec 2016 16:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(1)&lt;/p&gt;

&lt;p&gt;Effective Java第2章 创建和销毁对象&lt;/p&gt;

&lt;h5&gt;1.考虑用静态工厂方法代替构造器&lt;/h5&gt;

&lt;p&gt;静态工厂方法相较于构造器有四大优势：（1）它们有名称；（2）不必在每次调用它们的时候都创建一个新对象；（3）它们可以返回原返回类型的任何子类型的对象；（4）在创建参数化类型实例时，它们使代码变得更加简洁。两大缺点：（1）类如果不含公有的或受保护的构造器，就不能被子类化；（2）它们与其他的静态方法实际上并没有任何区别。&lt;/p&gt;

&lt;h5&gt;2.遇到多个构造器参数时要考虑用构建器&lt;/h5&gt;

&lt;p&gt;一个很直观的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;

    public static class Builder {
        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;

        public Builder(int servingSize, int servings){
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val){
            calories = val;
            return this;
        }

        public Builder fat(int val){
            fat = val;
            return this;
        }

        public NutritionFacts build(){
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder){
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要创建一个实例时只需根据自己的需要添加参数&lt;code&gt;NutritionFacts cocaCola = new Builder(240,8).calories(100).build();&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;3.用私有构造器或者枚举类型强化Singleton属性&lt;/h5&gt;

&lt;p&gt;除了非常常见的两种单例实现方法外，在Java 1.5之后我们有了一个更好的选择，使用单元素枚举类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum SingleTon {
    INSTANCE;
    public void orz() {
        //blablabla
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后如此调用&lt;code&gt;SingleTon s1 = SingleTon.INSTANCE;s1.orz();&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;4.通过私有构造器强化不可实例化的能力&lt;/h5&gt;

&lt;p&gt;对于一些只包含静态方法和静态域的工具类，我们不希望它被实例化，可以通过以下方式进行强化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UtilityClass{
    //Suppress default constructor for moninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;5.避免创建不必要的对象&lt;/h5&gt;

&lt;p&gt;一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。&lt;/p&gt;

&lt;p&gt;对于可重用的对象可以通过使用一个静态的初始化器&lt;code&gt;static{}&lt;/code&gt;来创建以避免重复创建，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。维护自己的对象池来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的，其中一个典型示例为数据库连接池。&lt;/p&gt;

&lt;h5&gt;6.消除过期的对象引用&lt;/h5&gt;

&lt;p&gt;要警惕内存泄漏问题，及时清除过期引用，使用合适的数据结构保存缓存、监听器以及其他回调，例如&lt;code&gt;WeakReference&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;7.避免使用终结方法&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;finalizer&lt;/code&gt;通常是不可预测的，也是很危险的，一般情况下是不必要的，并且该方法会导致严重的性能损失。如果类的对象中封装的资源确实需要终止，我们应该提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。终结方法有两种合法用途：1、充当&amp;rdquo;安全网&amp;rdquo;；2、终止非关键的本地资源。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 2</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</link>
      <pubDate>Thu, 15 Dec 2016 16:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(2)&lt;/p&gt;

&lt;p&gt;Effective Java第3章 对于所有对象都通用的方法&lt;/p&gt;

&lt;h5&gt;8.覆盖equals时请遵守通用约定&lt;/h5&gt;

&lt;p&gt;覆盖&lt;code&gt;Object.equals&lt;/code&gt;的时机：类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖&lt;code&gt;equals&lt;/code&gt;以实现期望的行为。这通常属于“值类”的情形，有一种“值类”不需要覆盖&lt;code&gt;equals&lt;/code&gt;方法，即用实例受控确保“每个值至多只存在一个对象”的类，比如枚举类型。&lt;/p&gt;

&lt;p&gt;在覆盖&lt;code&gt;equals&lt;/code&gt;方法的时候，你必须要遵守它的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自反性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x.equals(x)&lt;/code&gt;必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对称性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;，当且仅当&lt;code&gt;y.equals(x)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;时，&lt;code&gt;x.equals(y)&lt;/code&gt;必须返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传递性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x、y和z&lt;/code&gt;，如果&lt;code&gt;x.equals(y)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;，并且&lt;code&gt;y.equals(z)&lt;/code&gt;也返回&lt;code&gt;true&lt;/code&gt;，那么&lt;code&gt;x.equals(z)&lt;/code&gt;也必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一致性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x和y&lt;/code&gt;，只要&lt;code&gt;equals&lt;/code&gt;的比较操作在对象中所用的信息没有被修改，多次调用&lt;code&gt;x.equals(y)&lt;/code&gt;就会一致地返回&lt;code&gt;true&lt;/code&gt;，或者一致地返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于任何非null的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x,equals(null)&lt;/code&gt;必须返回false。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现高质量&lt;code&gt;equals&lt;/code&gt;方法的诀窍：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;==&lt;/code&gt;操作符检查“参数是否为这个对象的引用”。如果是，则返回&lt;code&gt;true&lt;/code&gt;。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;instanceof&lt;/code&gt;操作符检查“参数是否为正确的类型”。如果不是，则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把参数转换成正确的类型。因为转换前进行过&lt;code&gt;instanceof&lt;/code&gt;测试，所以确保会成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于既不是&lt;code&gt;float&lt;/code&gt;也不是&lt;code&gt;double&lt;/code&gt;类型的基本类型域，可以使用&lt;code&gt;==&lt;/code&gt;操作符进行比较，对于对象引用域，可以递归地调用&lt;code&gt;equals&lt;/code&gt;方法；对于&lt;code&gt;float&lt;/code&gt;域，可以使用&lt;code&gt;Float.compare&lt;/code&gt;方法；对于&lt;code&gt;double&lt;/code&gt;域，则使用&lt;code&gt;Double.compare&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;9.覆盖equals时总要覆盖hashCode&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Object.hashCode&lt;/code&gt;的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在应用程序的执行期间，只要对象的&lt;code&gt;equals&lt;/code&gt;方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次,&lt;code&gt;hashCode&lt;/code&gt;方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法都必须产生同样的整数结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是不相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;10.始终要覆盖toString&lt;/h5&gt;

&lt;p&gt;提供好的&lt;code&gt;toString&lt;/code&gt;实现可以使类用起来更加舒适，在实际应用中，&lt;code&gt;toString&lt;/code&gt;方法应该返回对象中包含的所有值得关注的信息。&lt;/p&gt;

&lt;h5&gt;4.通过私有构造器强化不可实例化的能力&lt;/h5&gt;

&lt;p&gt;对于一些只包含静态方法和静态域的工具类，我们不希望它被实例化，可以通过以下方式进行强化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UtilityClass{
    //Suppress default constructor for moninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;11.谨慎地覆盖clone&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Clone&lt;/code&gt;方法的通用约定：
对于任何对象&lt;code&gt;x&lt;/code&gt;，表达式&lt;code&gt;x.clone() != x&lt;/code&gt; 将会是&lt;code&gt;true&lt;/code&gt;，并且，表达式&lt;code&gt;x.clone().getClass() == x.getClass()&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但这些都不是绝对的要求。虽然通常情况下，表达式&lt;code&gt;x.clone().equals(x)&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但是，这也不是一个绝对的要求。拷贝对象往往会导致创建它的类的一个新实例，但它同时也会要求拷贝内部的数据结构。这个过程中没有调用构造器。&lt;/p&gt;

&lt;p&gt;所有实现了&lt;code&gt;Cloneable&lt;/code&gt;接口的类都应该用一个公有的方法覆盖&lt;code&gt;clone&lt;/code&gt;。此公有方法首先调用&lt;code&gt;super.clone&lt;/code&gt;，然后修正任何需要修正的域。一般情况下，这意味着要拷贝任何包含内部“深层结构”的可变对象，并用指向新对象的引用代替原来指向这些对象的引用。虽然，这些内部拷贝操作往往可以通过递归地调用&lt;code&gt;clone&lt;/code&gt;来完成，但这通常并不是最佳方法。如果该类只包含基本类型的域，或者指向不可变对象的引用，那么多半的情况是没有域需要修正。这条规则也有例外，譬如，代表序列号或其他唯一ID值得域，或者代表对象的创建时间的域，不管这些域是基本类型还是不可变的，它们也都需要被修正。&lt;/p&gt;

&lt;p&gt;另一个实现对象拷贝的好办法是提供一个拷贝构造器或拷贝工厂。拷贝构造器只是一个构造器，它唯一的参数类型是包含该构造器的类。如&lt;code&gt;public Go(Go go);&lt;/code&gt;，拷贝工厂是类似于拷贝构造器的静态工厂&lt;code&gt;public static Go newInstance(Go go);&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;12.考虑实现Comparable接口&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;compareTo&lt;/code&gt;方法的通用约定：&lt;/p&gt;

&lt;p&gt;讲这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。&lt;/p&gt;

&lt;p&gt;在下面的说明中，符号&lt;code&gt;sgn&lt;/code&gt;表示数学中的&lt;code&gt;signum&lt;/code&gt;函数，它根据表达式的值为负值、零和正值，分别返回-1、0或1。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实现者必须确保所有的&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(y)) == -sgn(y.compareTo(x))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现者还必须确保这个比较关系是可传递的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，实现者必须确保&lt;code&gt;x.compareTo(y) == 0&lt;/code&gt;暗示着所有的&lt;code&gt;z&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强烈建议&lt;code&gt;(x.compareTo(y) == 0) == (x.equals(y))&lt;/code&gt;，但这并非绝对必要。一般说来，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有内在的排序功能，但是与equals不一致。”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>