<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gaoge&#39;s island</title>
    <link>https://Gaogggg.github.io/tags/readingnotes/index.xml</link>
    <description>Recent content on Gaoge&#39;s island</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2016</copyright>
    <atom:link href="https://Gaogggg.github.io/tags/readingnotes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Effective Java ReadingNotes 4</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes4/</link>
      <pubDate>Fri, 16 Dec 2016 18:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes4/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(4)&lt;/p&gt;

&lt;p&gt;Effective Java第5章 泛型&lt;/p&gt;

&lt;h5&gt;23.请不要在新代码中使用原生态类型&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Set&amp;lt;Object&amp;gt;&lt;/code&gt;是个参数化类型，表示可以包含任何对象类型的一个集合；&lt;code&gt;Set&amp;lt;?&amp;gt;&lt;/code&gt;则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；&lt;code&gt;Set&lt;/code&gt;则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。&lt;/p&gt;

&lt;h5&gt;24.消除非受检警告&lt;/h5&gt;

&lt;p&gt;本处主要介绍比较难以消除的警告的示例。&lt;/p&gt;

&lt;p&gt;如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个&lt;code&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/code&gt;注解来禁止这条警告。&lt;strong&gt;应该始终在尽可能小的范围中使用&lt;code&gt;SuppressWarnings&lt;/code&gt;注解，并且每当使用该注解时都要添加一条注释，说明为什么这么做是安全的。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;25.列表优先于数组&lt;/h5&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 3</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes3/</link>
      <pubDate>Fri, 16 Dec 2016 14:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes3/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(3)&lt;/p&gt;

&lt;p&gt;Effective Java第4章 类和接口&lt;/p&gt;

&lt;h5&gt;13.使类和成员的可访问性最小化&lt;/h5&gt;

&lt;p&gt;访问控制机制决定了类、接口和成员的可访问性。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符共同决定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尽可能地使每个类或者成员不被外界访问。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;私有的&lt;code&gt;private&lt;/code&gt;——只有在声明该成员的顶层类内部才可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包级私有的&lt;code&gt;package-private/default&lt;/code&gt;——声明该成员的包内部的任何类都可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;受保护的&lt;code&gt;protected&lt;/code&gt;——声明该成员的类的子类可以访问这个成员（有一些限制），并且，声明该成员的包内部的任何类也可以访问这个成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;公有的&lt;code&gt;public&lt;/code&gt;——在任何地方都可以访问该成员。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现了Serializable接口的类的私有域可能会被“泄漏”。&lt;/p&gt;

&lt;p&gt;子类中的访问级别不允许低于超类中的访问级别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;除了公有静态final域的特殊情形之外，公有类都不应该包含公有域。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;14.在公有类中使用访问方法而非公有域&lt;/h5&gt;

&lt;p&gt;如果类可以在它所在的包的外部进行访问，就提供访问方法。公有类永远都不应该暴露可变的域。但是，有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变还是不可变的。&lt;/p&gt;

&lt;h5&gt;15.使可变性最小化&lt;/h5&gt;

&lt;p&gt;不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。不可变类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。&lt;/p&gt;

&lt;p&gt;为了使类成为不可变，要遵循下面五条规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要提供任何会修改对象状态的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保证类不会被扩展。一般使类成为&lt;code&gt;final&lt;/code&gt;，但后面还会讨论其他做法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使所有的域都是&lt;code&gt;final&lt;/code&gt;的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使所有的域都成为私有的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确保对于任何可变组件的互斥访问。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不可变对象本质上是线程安全的，它们不要求同步；不仅可以共享不可变对象，甚至也可以共享它们的内部信息；不可以对象为其他对象提供了大量的构件。&lt;strong&gt;不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让不可变的类变成&lt;code&gt;final&lt;/code&gt;的另一种方法就是，让类的所有构造器都变成私有的或者包级私有的，并添加公有的静态工厂来代替公有的构造器。&lt;/p&gt;

&lt;h5&gt;*16.复合优先于继承&lt;/h5&gt;

&lt;p&gt;继承打破了封装性，子类依赖于其超类中特定功能的实现细节。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。&lt;/p&gt;

&lt;p&gt;为了避免继承导致的脆弱性，我们可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {
    private final Set&lt;E&gt; s;

    public ForwardingSet(Set&lt;E&gt; s) {
        this.s = s;
    }

    public void clear() {
        s.clear();
    }

    public boolean contains(Object o) {
        return s.contains(o);
    }

    public boolean isEmpty() {
        return s.isEmpty();
    }

    public int size() {
        return s.size();
    }

    public Iterator&lt;E&gt; iterator() {
        return s.iterator();
    }

    public boolean add(E e) {
        return s.add(e);
    }

    public boolean remove(Object o) {
        return s.remove(o);
    }

    public boolean containsAll(Collection&lt;?&gt; c) {
        return s.containsAll(c);
    }

    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return s.addAll(c);
    }

    public boolean removeAll(Collection&lt;?&gt; c) {
        return s.removeAll(c);
    }

    public boolean retainAll(Collection&lt;?&gt; c) {
        return s.retainAll(c);
    }

    public Object[] toArray() {
        return s.toArray();
    }

    public &lt;T&gt; T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}

public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {
    private int addCount = 0;

    public InstrumentedSet(Set&lt;E&gt; s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;17.要么为继承而设计，并提供文档说明，要么就禁止继承&lt;/h5&gt;

&lt;p&gt;为继承而设计的类必须有文档说明它可覆盖&lt;code&gt;overridable&lt;/code&gt;的方法的自用性，且必须通过某种形式提供适当的钩子&lt;code&gt;hook&lt;/code&gt;，以便能够进入到它的内部工作流程中，这种形式可以使精心选择的受保护&lt;code&gt;protected&lt;/code&gt;的方法，也可以是受保护的域，后者比较少见。该类的唯一的测试方法就是编写子类。&lt;/p&gt;

&lt;p&gt;为了允许继承，类还必须遵守其他一些约束。&lt;strong&gt;构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;18.接口优于抽象类&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现有的类可以很容易被更新，以实现新的接口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口是定义&lt;code&gt;mixin(混合类型)&lt;/code&gt;的理想选择。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口允许我们构造非层次结构的类型框架。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抽象类的演变比接口的演变要容易得多。&lt;strong&gt;接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。&lt;/strong&gt;&lt;/p&gt;

&lt;h5&gt;19.接口只用于定义类型&lt;/h5&gt;

&lt;p&gt;接口应该只被用来定义类型，不应该被用来导出常量，导出常量可以使用枚举类型和不可实例化的工具类。&lt;/p&gt;

&lt;h5&gt;20.类层次优于标签类&lt;/h5&gt;

&lt;p&gt;标签类过于冗长、容易出错，并且效率低下。标签类很少有适用的时候，当你想要编写一个包含显式标签域的类时，应该考虑一下这个标签是否可以被取消，这个类是否可以使用类层次来代替。&lt;/p&gt;

&lt;p&gt;以下为一个标签类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Figure {  
    enum Shape { RECTANGLE, CIRCLE };  
  
    // Tag field - the shape of this figure  
    final Shape shape;  
  
    // These fields are used only if shape is RECTANGLE  
    double length;  
    double width;  
  
    // This field is used only if shape is CIRCLE  
    double radius;  
  
    // Constructor for circle  
    Figure(double radius) {  
        shape = Shape.CIRCLE;  
        this.radius = radius;  
    }  
  
    // Constructor for rectangle  
    Figure(double length, double width) {  
        shape = Shape.RECTANGLE;  
        this.length = length;  
        this.width = width;  
    }  
  
    double area() {  
        switch(shape) {  
          case RECTANGLE:  
            return length * width;  
          case CIRCLE:  
            return Math.PI * (radius * radius);  
          default:  
            throw new AssertionError();  
        }  
    }  
}&lt;/code&gt;&lt;/pre&gt;  

&lt;p&gt;修改后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class Figure {  
    abstract double area();  
}  
class Circle extends Figure {  
    final double radius;  
  
    Circle(double radius) { this.radius = radius; }  
  
    double area() { return Math.PI * (radius * radius); }  
}  
class Rectangle extends Figure {  
    final double length;  
    final double width;  
  
    Rectangle(double length, double width) {  
        this.length = length;  
        this.width  = width;  
    }  
    double area() { return length * width; }  
}  
class Square extends Rectangle {  
    Square(double side) {  
        super(side, side);  
    }  
}&lt;/code&gt;&lt;/pre&gt;  

&lt;h5&gt;21.用函数对象表示策略&lt;/h5&gt;

&lt;p&gt;函数指针的主要用途就是实现策略模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体的策略只被使用一次时，通常使用匿名内部类来声明和实例化这个具体策略类。当一个具体策略被设计用来重复使用的时候，它的类通常要被实现为私有的静态成员，并通过公有的静态final域被导出，其类型为该策略接口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Arrays.sort(StringArray,new Comparator&lt;String&gt;(){
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Host {
    private static class StrLenCmp implements Comparator&lt;String&gt;,Serializable{
 
        @Override
        public int compare(String s1, String s2) {
            return s1.length() - s2.length();
        }
    }
     
    public static final Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = new StrLenCmp();
     
    public static void main(String[] args) {
        String s1 = &#34;&#34;;
        String s2 = &#34;&#34;;
        int result = Host.STRING_LENGTH_COMPARATOR.compare(s1, s2);
        System.out.println(result);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;22.优先考虑静态成员类&lt;/h5&gt;

&lt;p&gt;嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类提供服务。如果嵌套类将来可能会用于其他的某个环境中，他就应该是顶层类。嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类。除了第一种之外，其他三种都称为内部类。&lt;/p&gt;

&lt;p&gt;从语法上讲，静态成员类和非静态成员类之间的唯一区别是，静态成员类的声明中包含修饰符&lt;code&gt;static&lt;/code&gt;。尽管他们的语法非常相似，但是两种嵌套类有很大的不同。非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修改过的&lt;code&gt;this&lt;/code&gt;构造获得外围实例的引用。如果嵌套类的实例可以在他外围类的实力之外独立存在，这个嵌套类就必须是静态成员类，在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。&lt;/p&gt;

&lt;p&gt;当非静态成员类的实例被创建的时候，他和外围之间的关联关系也随之被创立起来；而且，这种关联关系以后不能被修改。通常情况下，当在外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关系被自动建立起来。
使用表达式enclosingInstance.new MemberClass(args)来手工建立这种关联关系也是有可能的，但是很少使用。正如你所预料的那样，这种关联关系需要消耗费静态成员类的实例空间，并且构造的时间开销。&lt;/p&gt;

&lt;p&gt;如果声明成员类不要求访问外围实例，就要始终把&lt;code&gt;static&lt;/code&gt;修饰符放在他的声明中。&lt;/p&gt;

&lt;p&gt;匿名类的三种常见用法：1.动态的创建函数对象，如&lt;code&gt;sort&lt;/code&gt;方法的调用利用了匿名的&lt;code&gt;Comparator&lt;/code&gt;实例；2.创建过程对象，如&lt;code&gt;Runnable&lt;/code&gt;、&lt;code&gt;Thread&lt;/code&gt;或者&lt;code&gt;TimerTask&lt;/code&gt;实例；3.在静态工厂方法的内部使用。&lt;/p&gt;

&lt;p&gt;如果一个嵌套类需要在单个方法之外仍然是可见的，或者他太长了，不适合方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则就做成静态的。假设这个嵌套类属于一个方法的内部，如果你需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就把他做成匿名类；否则，就做成局部类。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 2</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</link>
      <pubDate>Thu, 15 Dec 2016 19:18:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes2/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(2)&lt;/p&gt;

&lt;p&gt;Effective Java第3章 对于所有对象都通用的方法&lt;/p&gt;

&lt;h5&gt;8.覆盖equals时请遵守通用约定&lt;/h5&gt;

&lt;p&gt;覆盖&lt;code&gt;Object.equals&lt;/code&gt;的时机：类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖&lt;code&gt;equals&lt;/code&gt;以实现期望的行为。这通常属于“值类”的情形，有一种“值类”不需要覆盖&lt;code&gt;equals&lt;/code&gt;方法，即用实例受控确保“每个值至多只存在一个对象”的类，比如枚举类型。&lt;/p&gt;

&lt;p&gt;在覆盖&lt;code&gt;equals&lt;/code&gt;方法的时候，你必须要遵守它的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自反性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x.equals(x)&lt;/code&gt;必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对称性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;，当且仅当&lt;code&gt;y.equals(x)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;时，&lt;code&gt;x.equals(y)&lt;/code&gt;必须返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传递性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x、y和z&lt;/code&gt;，如果&lt;code&gt;x.equals(y)&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;，并且&lt;code&gt;y.equals(z)&lt;/code&gt;也返回&lt;code&gt;true&lt;/code&gt;，那么&lt;code&gt;x.equals(z)&lt;/code&gt;也必须返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一致性。对于任何非&lt;code&gt;null&lt;/code&gt;的引用值&lt;code&gt;x和y&lt;/code&gt;，只要&lt;code&gt;equals&lt;/code&gt;的比较操作在对象中所用的信息没有被修改，多次调用&lt;code&gt;x.equals(y)&lt;/code&gt;就会一致地返回&lt;code&gt;true&lt;/code&gt;，或者一致地返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于任何非null的引用值&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;x,equals(null)&lt;/code&gt;必须返回false。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现高质量&lt;code&gt;equals&lt;/code&gt;方法的诀窍：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;==&lt;/code&gt;操作符检查“参数是否为这个对象的引用”。如果是，则返回&lt;code&gt;true&lt;/code&gt;。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;instanceof&lt;/code&gt;操作符检查“参数是否为正确的类型”。如果不是，则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把参数转换成正确的类型。因为转换前进行过&lt;code&gt;instanceof&lt;/code&gt;测试，所以确保会成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于既不是&lt;code&gt;float&lt;/code&gt;也不是&lt;code&gt;double&lt;/code&gt;类型的基本类型域，可以使用&lt;code&gt;==&lt;/code&gt;操作符进行比较，对于对象引用域，可以递归地调用&lt;code&gt;equals&lt;/code&gt;方法；对于&lt;code&gt;float&lt;/code&gt;域，可以使用&lt;code&gt;Float.compare&lt;/code&gt;方法；对于&lt;code&gt;double&lt;/code&gt;域，则使用&lt;code&gt;Double.compare&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;9.覆盖equals时总要覆盖hashCode&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Object.hashCode&lt;/code&gt;的通用约定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在应用程序的执行期间，只要对象的&lt;code&gt;equals&lt;/code&gt;方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次,&lt;code&gt;hashCode&lt;/code&gt;方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法都必须产生同样的整数结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals(Object)&lt;/code&gt;方法比较是不相等的，那么调用这两个对象中任意一个对象的&lt;code&gt;hashCode&lt;/code&gt;方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;10.始终要覆盖toString&lt;/h5&gt;

&lt;p&gt;提供好的&lt;code&gt;toString&lt;/code&gt;实现可以使类用起来更加舒适，在实际应用中，&lt;code&gt;toString&lt;/code&gt;方法应该返回对象中包含的所有值得关注的信息。&lt;/p&gt;

&lt;h5&gt;11.谨慎地覆盖clone&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Clone&lt;/code&gt;方法的通用约定：
对于任何对象&lt;code&gt;x&lt;/code&gt;，表达式&lt;code&gt;x.clone() != x&lt;/code&gt; 将会是&lt;code&gt;true&lt;/code&gt;，并且，表达式&lt;code&gt;x.clone().getClass() == x.getClass()&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但这些都不是绝对的要求。虽然通常情况下，表达式&lt;code&gt;x.clone().equals(x)&lt;/code&gt;将会是&lt;code&gt;true&lt;/code&gt;，但是，这也不是一个绝对的要求。拷贝对象往往会导致创建它的类的一个新实例，但它同时也会要求拷贝内部的数据结构。这个过程中没有调用构造器。&lt;/p&gt;

&lt;p&gt;所有实现了&lt;code&gt;Cloneable&lt;/code&gt;接口的类都应该用一个公有的方法覆盖&lt;code&gt;clone&lt;/code&gt;。此公有方法首先调用&lt;code&gt;super.clone&lt;/code&gt;，然后修正任何需要修正的域。一般情况下，这意味着要拷贝任何包含内部“深层结构”的可变对象，并用指向新对象的引用代替原来指向这些对象的引用。虽然，这些内部拷贝操作往往可以通过递归地调用&lt;code&gt;clone&lt;/code&gt;来完成，但这通常并不是最佳方法。如果该类只包含基本类型的域，或者指向不可变对象的引用，那么多半的情况是没有域需要修正。这条规则也有例外，譬如，代表序列号或其他唯一ID值得域，或者代表对象的创建时间的域，不管这些域是基本类型还是不可变的，它们也都需要被修正。&lt;/p&gt;

&lt;p&gt;另一个实现对象拷贝的好办法是提供一个拷贝构造器或拷贝工厂。拷贝构造器只是一个构造器，它唯一的参数类型是包含该构造器的类。如&lt;code&gt;public Go(Go go);&lt;/code&gt;，拷贝工厂是类似于拷贝构造器的静态工厂&lt;code&gt;public static Go newInstance(Go go);&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;12.考虑实现Comparable接口&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;compareTo&lt;/code&gt;方法的通用约定：&lt;/p&gt;

&lt;p&gt;讲这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。&lt;/p&gt;

&lt;p&gt;在下面的说明中，符号&lt;code&gt;sgn&lt;/code&gt;表示数学中的&lt;code&gt;signum&lt;/code&gt;函数，它根据表达式的值为负值、零和正值，分别返回-1、0或1。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实现者必须确保所有的&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(y)) == -sgn(y.compareTo(x))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现者还必须确保这个比较关系是可传递的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，实现者必须确保&lt;code&gt;x.compareTo(y) == 0&lt;/code&gt;暗示着所有的&lt;code&gt;z&lt;/code&gt;都满足&lt;code&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强烈建议&lt;code&gt;(x.compareTo(y) == 0) == (x.equals(y))&lt;/code&gt;，但这并非绝对必要。一般说来，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有内在的排序功能，但是与equals不一致。”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Effective Java ReadingNotes 1</title>
      <link>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</link>
      <pubDate>Thu, 15 Dec 2016 16:16:24 +0800</pubDate>
      
      <guid>https://gaogggg.github.io/post/readingnotes/effective-java-readingnotes1/</guid>
      <description>&lt;p&gt;Effective Java阅读笔记(1)&lt;/p&gt;

&lt;p&gt;Effective Java第2章 创建和销毁对象&lt;/p&gt;

&lt;h5&gt;1.考虑用静态工厂方法代替构造器&lt;/h5&gt;

&lt;p&gt;静态工厂方法相较于构造器有四大优势：（1）它们有名称；（2）不必在每次调用它们的时候都创建一个新对象；（3）它们可以返回原返回类型的任何子类型的对象；（4）在创建参数化类型实例时，它们使代码变得更加简洁。两大缺点：（1）类如果不含公有的或受保护的构造器，就不能被子类化；（2）它们与其他的静态方法实际上并没有任何区别。&lt;/p&gt;

&lt;h5&gt;2.遇到多个构造器参数时要考虑用构建器&lt;/h5&gt;

&lt;p&gt;一个很直观的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;

    public static class Builder {
        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;

        public Builder(int servingSize, int servings){
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val){
            calories = val;
            return this;
        }

        public Builder fat(int val){
            fat = val;
            return this;
        }

        public NutritionFacts build(){
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder){
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要创建一个实例时只需根据自己的需要添加参数&lt;code&gt;NutritionFacts cocaCola = new Builder(240,8).calories(100).build();&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;3.用私有构造器或者枚举类型强化Singleton属性&lt;/h5&gt;

&lt;p&gt;除了非常常见的两种单例实现方法外，在Java 1.5之后我们有了一个更好的选择，使用单元素枚举类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum SingleTon {
    INSTANCE;
    public void orz() {
        //blablabla
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后如此调用&lt;code&gt;SingleTon s1 = SingleTon.INSTANCE;s1.orz();&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;4.通过私有构造器强化不可实例化的能力&lt;/h5&gt;

&lt;p&gt;对于一些只包含静态方法和静态域的工具类，我们不希望它被实例化，可以通过以下方式进行强化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UtilityClass{
    //Suppress default constructor for moninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;5.避免创建不必要的对象&lt;/h5&gt;

&lt;p&gt;一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。&lt;/p&gt;

&lt;p&gt;对于可重用的对象可以通过使用一个静态的初始化器&lt;code&gt;static{}&lt;/code&gt;来创建以避免重复创建，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。维护自己的对象池来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的，其中一个典型示例为数据库连接池。&lt;/p&gt;

&lt;h5&gt;6.消除过期的对象引用&lt;/h5&gt;

&lt;p&gt;要警惕内存泄漏问题，及时清除过期引用，使用合适的数据结构保存缓存、监听器以及其他回调，例如&lt;code&gt;WeakReference&lt;/code&gt;。&lt;/p&gt;

&lt;h5&gt;7.避免使用终结方法&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;finalizer&lt;/code&gt;通常是不可预测的，也是很危险的，一般情况下是不必要的，并且该方法会导致严重的性能损失。如果类的对象中封装的资源确实需要终止，我们应该提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。终结方法有两种合法用途：1、充当&amp;rdquo;安全网&amp;rdquo;；2、终止非关键的本地资源。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>